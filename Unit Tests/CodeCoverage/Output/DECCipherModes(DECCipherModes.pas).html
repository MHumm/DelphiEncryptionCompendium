<!DOCTYPE html>
<html>
<head>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type" />
<title>Delphi CodeCoverage Coverage Report</title>
<style type="text/css">
body {max-width: max-content;margin: auto;}
table {border-spacing:0;}
table, td, th {border: 0;}
td, th {background: white; margin: 0; padding: .5em 1em}
table small { color: #777; }
p, h1, h2, h3, th {font-family: verdana,arial,sans-serif; font-size: 10pt;}
td {font-family: consolas,courier,monospace; font-size: 10pt;}
thead, th {background: #808C98; color: white; }
table th small { color: #ddd; }
th[idx] {cursor: pointer; user-select: none;}
table.o tr td:nth-child(1) {font-weight: bold;}
table.o tr td:nth-child(2) {text-align: right;}
table.o tr td {border-width: 1px;}
table.s {width: calc(min(80em, 95vw));}
table.s tr td {padding: .1em .5em; white-space: pre-wrap;}
table.s tr td:first-child {text-align: right; font-weight: bold; vertical-align: top}
table.s tr.notcovered td {background: #ddf;}
table.s tr.nocodegen td {background: #ffe;}
table.s tr.covered td {background: #cfc;}
table.s tr.covered td:first-child {color: green;}
table.s {border-width: 1px 0 1px 1px;}
table.sum td { background-position: 50%; background-repeat: no-repeat; background-size: 90% 70%; }
table.sum tr:nth-child(odd) td { background-color: #f4f4f4}
table.sum tr:hover td, tr:hover td a { filter: invert(10%) }
table.sum tr th {text-align:left; border: .5px solid #5d4e4c; height: 1em}
table.sum tr td {text-align:right;}
table.sum tr td:first-child {text-align:left;}
table.sum thead th { position: sticky; top:0; }
table.sum thead tr + tr th { position: sticky; top: calc(2.5em - 2px); }
table.sum tfoot th { position: sticky; bottom:0; }
table.sum tfoot th+th {text-align: right;}
table.sum a, table.sum a:visited {color: #5d4e4c; text-decoration: none;}
#nav {position: fixed;overflow: visible;left: min(calc(50% + 41em), calc(100% - 6em));padding: .1em .5em .1em .2em;background: white;box-shadow: 1px 1px 3px #888;}
#nav div {opacity: .3; user-select: none; pointer-events: none;}
#nav div.active {opacity: 1;	cursor: pointer;	pointer-events: initial;}
#nav div.active:hover {color: #00A;}
</style>
</head>
<body>
<p>Coverage report for <bold>DECCipherModes (..\..\Source\DECCipherModes.pas)</bold>.</p>
<p>Generated at 30.11.2022 22:06:19 by <a href="https://github.com/DelphiCodeCoverage/DelphiCodeCoverage" target="_blank" title="DelphiCodeCoverage on GitHub">DelphiCodeCoverage</a> - an open source tool for Delphi Code Coverage.</p>
<p>Statistics for ..\..\Source\DECCipherModes.pas</p>
<table class="o"><tr><td>Number of lines covered<td>382<td rowspan=3 style="background: conic-gradient(#9fe098 83%, #eee 83%);width: 4.5em; border-radius: 50%"><tr><td>Number of lines with code gen<td>457<tr><td>Line coverage<td>83<small>.6</small>&nbsp;%</table>
<br><br>
<div id="nav"><div id="nav-prev">&#x25b2; Prev</div><div id="nav-next">&#x25bc; Next</div></div>
<table class="s">
<tr class="nocodegen"><td>1<td>{*****************************************************************************
<tr class="nocodegen"><td>2<td>  The DEC team (see file NOTICE.txt) licenses this file
<tr class="nocodegen"><td>3<td>  to you under the Apache License, Version 2.0 (the
<tr class="nocodegen"><td>4<td>  &quot;License&quot;); you may not use this file except in compliance
<tr class="nocodegen"><td>5<td>  with the License. A copy of this licence is found in the root directory
<tr class="nocodegen"><td>6<td>  of this project in the file LICENCE.txt or alternatively at
<tr class="nocodegen"><td>7<td>
<tr class="nocodegen"><td>8<td>    http://www.apache.org/licenses/LICENSE-2.0
<tr class="nocodegen"><td>9<td>
<tr class="nocodegen"><td>10<td>  Unless required by applicable law or agreed to in writing,
<tr class="nocodegen"><td>11<td>  software distributed under the License is distributed on an
<tr class="nocodegen"><td>12<td>  &quot;AS IS&quot; BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
<tr class="nocodegen"><td>13<td>  KIND, either express or implied.  See the License for the
<tr class="nocodegen"><td>14<td>  specific language governing permissions and limitations
<tr class="nocodegen"><td>15<td>  under the License.
<tr class="nocodegen"><td>16<td>*****************************************************************************}
<tr class="nocodegen"><td>17<td>unit DECCipherModes;
<tr class="nocodegen"><td>18<td>
<tr class="nocodegen"><td>19<td>interface
<tr class="nocodegen"><td>20<td>
<tr class="nocodegen"><td>21<td>{$INCLUDE DECOptions.inc}
<tr class="nocodegen"><td>22<td>
<tr class="nocodegen"><td>23<td>uses
<tr class="nocodegen"><td>24<td>  {$IFDEF FPC}
<tr class="nocodegen"><td>25<td>  SysUtils,
<tr class="nocodegen"><td>26<td>  {$ELSE}
<tr class="nocodegen"><td>27<td>  System.SysUtils,
<tr class="nocodegen"><td>28<td>  {$ENDIF}
<tr class="nocodegen"><td>29<td>  DECTypes, DECCipherBase, DECCipherModesGCM, DECCipherInterface;
<tr class="nocodegen"><td>30<td>
<tr class="nocodegen"><td>31<td>type
<tr class="nocodegen"><td>32<td>  /// &lt;summary&gt;
<tr class="nocodegen"><td>33<td>  ///   Class type of the cipher base class implementing all block
<tr class="nocodegen"><td>34<td>  ///   concatenation modes.
<tr class="nocodegen"><td>35<td>  /// &lt;/summary&gt;
<tr class="nocodegen"><td>36<td>  TDECCipherModesClass = class of TDECCipherModes;
<tr class="nocodegen"><td>37<td>
<tr class="nocodegen"><td>38<td>  /// &lt;summary&gt;
<tr class="nocodegen"><td>39<td>  ///   Most ciphers are block oriented and thus work on blocks of a fixed size.
<tr class="nocodegen"><td>40<td>  ///   In order to not encrypt each block separately without any link to his
<tr class="nocodegen"><td>41<td>  ///   predecessor and sucessor, which would make attacks on the encrypted data
<tr class="nocodegen"><td>42<td>  ///   easier, each block should be linked with his predecessor (or the
<tr class="nocodegen"><td>43<td>  ///   initialization vector). This class implements the various supported
<tr class="nocodegen"><td>44<td>  ///   algorithms for linking blocks.
<tr class="nocodegen"><td>45<td>  /// &lt;/summary&gt;
<tr class="nocodegen"><td>46<td>  TDECCipherModes = class(TDECCipher, IDECAuthenticatedCipher)
<tr class="nocodegen"><td>47<td>  strict private
<tr class="nocodegen"><td>48<td>    /// &lt;summary&gt;
<tr class="nocodegen"><td>49<td>    ///   Returns the data which shall get authenticated when using a cipher
<tr class="nocodegen"><td>50<td>    ///   mode which provides authentication support as well.
<tr class="nocodegen"><td>51<td>    /// &lt;/summary&gt;
<tr class="nocodegen"><td>52<td>    /// &lt;returns&gt;
<tr class="nocodegen"><td>53<td>    ///   Data to be authenticated. Raises an EDECCipherException if this is
<tr class="nocodegen"><td>54<td>    ///   called for a cipher mode not supporting authentication.
<tr class="nocodegen"><td>55<td>    /// &lt;/returns&gt;
<tr class="nocodegen"><td>56<td>    /// &lt;exception cref=&quot;EDECCipherException&quot;&gt;
<tr class="nocodegen"><td>57<td>    ///   Exception raised if called for a cipher mode not supporting
<tr class="nocodegen"><td>58<td>    ///   authentication.
<tr class="nocodegen"><td>59<td>    /// &lt;/exception&gt;
<tr class="nocodegen"><td>60<td>    function  GetDataToAuthenticate: TBytes;
<tr class="nocodegen"><td>61<td>    /// &lt;summary&gt;
<tr class="nocodegen"><td>62<td>    ///   Returns the length of the resulting authentication value if a
<tr class="nocodegen"><td>63<td>    ///   cipher mode which provides authentication support as well is used.
<tr class="nocodegen"><td>64<td>    /// &lt;/summary&gt;
<tr class="nocodegen"><td>65<td>    /// &lt;returns&gt;
<tr class="nocodegen"><td>66<td>    ///   Length of the authentication result in bit. Raises an
<tr class="nocodegen"><td>67<td>    ///   EDECCipherException if this is called for a cipher mode not supporting
<tr class="nocodegen"><td>68<td>    ///   authentication.
<tr class="nocodegen"><td>69<td>    /// &lt;/returns&gt;
<tr class="nocodegen"><td>70<td>    /// &lt;exception cref=&quot;EDECCipherException&quot;&gt;
<tr class="nocodegen"><td>71<td>    ///   Exception raised if called for a cipher mode not supporting
<tr class="nocodegen"><td>72<td>    ///   authentication.
<tr class="nocodegen"><td>73<td>    /// &lt;/exception&gt;
<tr class="nocodegen"><td>74<td>    function  GetAuthenticationResultBitLength: Integer;
<tr class="nocodegen"><td>75<td>    /// &lt;summary&gt;
<tr class="nocodegen"><td>76<td>    ///   Returns the value calculated over the data to be authenticated if a
<tr class="nocodegen"><td>77<td>    ///   cipher mode which provides authentication support as well is used.
<tr class="nocodegen"><td>78<td>    ///   The value will be returned even if decryption resulted in a wrong value.
<tr class="nocodegen"><td>79<td>    ///   A wrong authentication result on decryption is signalled via exception.
<tr class="nocodegen"><td>80<td>    /// &lt;/summary&gt;
<tr class="nocodegen"><td>81<td>    /// &lt;returns&gt;
<tr class="nocodegen"><td>82<td>    ///   Result of the authentication. Raises an EDECCipherException if this is
<tr class="nocodegen"><td>83<td>    ///   called for a cipher mode not supporting authentication.
<tr class="nocodegen"><td>84<td>    /// &lt;/returns&gt;
<tr class="nocodegen"><td>85<td>    /// &lt;exception cref=&quot;EDECCipherException&quot;&gt;
<tr class="nocodegen"><td>86<td>    ///   Exception raised if called for a cipher mode not supporting
<tr class="nocodegen"><td>87<td>    ///   authentication.
<tr class="nocodegen"><td>88<td>    /// &lt;/exception&gt;
<tr class="nocodegen"><td>89<td>    function  GetCalcAuthenticatonResult: TBytes;
<tr class="nocodegen"><td>90<td>    /// &lt;summary&gt;
<tr class="nocodegen"><td>91<td>    ///   Defines the data which shall get authenticated when using a cipher
<tr class="nocodegen"><td>92<td>    ///   mode which provides authentication support as well.
<tr class="nocodegen"><td>93<td>    /// &lt;/summary&gt;
<tr class="nocodegen"><td>94<td>    /// &lt;param name=&quot;Value&quot;&gt;
<tr class="nocodegen"><td>95<td>    ///   Data to be authenticated. Raises an EDECCipherException if this is
<tr class="nocodegen"><td>96<td>    ///   called for a cipher mode not supporting authentication.
<tr class="nocodegen"><td>97<td>    /// &lt;/param&gt;
<tr class="nocodegen"><td>98<td>    /// &lt;exception cref=&quot;EDECCipherException&quot;&gt;
<tr class="nocodegen"><td>99<td>    ///   Exception raised if called for a cipher mode not supporting
<tr class="nocodegen"><td>100<td>    ///   authentication.
<tr class="nocodegen"><td>101<td>    /// &lt;/exception&gt;
<tr class="nocodegen"><td>102<td>    procedure SetDataToAuthenticate(const Value: TBytes);
<tr class="nocodegen"><td>103<td>    /// &lt;summary&gt;
<tr class="nocodegen"><td>104<td>    ///   Sets the length of the resulting authentication value if a
<tr class="nocodegen"><td>105<td>    ///   cipher mode which provides authentication support as well is used.
<tr class="nocodegen"><td>106<td>    /// &lt;/summary&gt;
<tr class="nocodegen"><td>107<td>    /// &lt;param name=&quot;Value&quot;&gt;
<tr class="nocodegen"><td>108<td>    ///   Length of the authentication result in bit. Raises an
<tr class="nocodegen"><td>109<td>    ///   EDECCipherException if this is called for a cipher mode not supporting
<tr class="nocodegen"><td>110<td>    ///   authentication.
<tr class="nocodegen"><td>111<td>    /// &lt;/param&gt;
<tr class="nocodegen"><td>112<td>    /// &lt;exception cref=&quot;EDECCipherException&quot;&gt;
<tr class="nocodegen"><td>113<td>    ///   Exception raised if called for a cipher mode not supporting
<tr class="nocodegen"><td>114<td>    ///   authentication.
<tr class="nocodegen"><td>115<td>    /// &lt;/exception&gt;
<tr class="nocodegen"><td>116<td>    procedure SetAuthenticationResultBitLength(const Value: Integer);
<tr class="nocodegen"><td>117<td>    /// &lt;summary&gt;
<tr class="nocodegen"><td>118<td>    ///   Returns the value set as expected authenthication value for ciphers
<tr class="nocodegen"><td>119<td>    ///   providing authehtication features as well. Raises an
<tr class="nocodegen"><td>120<td>    ///   EDECCipherException if this is called for a cipher mode not supporting
<tr class="nocodegen"><td>121<td>    ///   authentication.
<tr class="nocodegen"><td>122<td>    /// &lt;/summary&gt;
<tr class="nocodegen"><td>123<td>    /// &lt;exception cref=&quot;EDECCipherException&quot;&gt;
<tr class="nocodegen"><td>124<td>    ///   Exception raised if called for a cipher mode not supporting
<tr class="nocodegen"><td>125<td>    ///   authentication.
<tr class="nocodegen"><td>126<td>    /// &lt;/exception&gt;
<tr class="nocodegen"><td>127<td>    function GetExpectedAuthenticationResult: TBytes;
<tr class="nocodegen"><td>128<td>    /// &lt;summary&gt;
<tr class="nocodegen"><td>129<td>    ///   Sets the value used as expected authenthication value when decrypting
<tr class="nocodegen"><td>130<td>    ///   and a cipher providing authehtication features is being used. Raises an
<tr class="nocodegen"><td>131<td>    ///   EDECCipherException if this is called for a cipher mode not supporting
<tr class="nocodegen"><td>132<td>    ///   authentication.
<tr class="nocodegen"><td>133<td>    /// &lt;/summary&gt;
<tr class="nocodegen"><td>134<td>    /// &lt;exception cref=&quot;EDECCipherException&quot;&gt;
<tr class="nocodegen"><td>135<td>    ///   Exception raised if called for a cipher mode not supporting
<tr class="nocodegen"><td>136<td>    ///   authentication.
<tr class="nocodegen"><td>137<td>    /// &lt;/exception&gt;
<tr class="nocodegen"><td>138<td>    procedure SetExpectedAuthenticationResult(const Value: TBytes);
<tr class="nocodegen"><td>139<td>  strict protected
<tr class="nocodegen"><td>140<td>    /// &lt;summary&gt;
<tr class="nocodegen"><td>141<td>    ///   Implementation of the Galois counter mode. Only created when gmGCM is
<tr class="nocodegen"><td>142<td>    ///   set as mode.
<tr class="nocodegen"><td>143<td>    /// &lt;/summary&gt;
<tr class="nocodegen"><td>144<td>    FGCM : TGCM;
<tr class="nocodegen"><td>145<td>    /// &lt;summary&gt;
<tr class="nocodegen"><td>146<td>    ///   Raises an EDECCipherException exception and provides the correct value
<tr class="nocodegen"><td>147<td>    ///   for block size in that message
<tr class="nocodegen"><td>148<td>    /// &lt;/summary&gt;
<tr class="nocodegen"><td>149<td>    /// &lt;exception cref=&quot;EDECCipherException&quot;&gt;
<tr class="nocodegen"><td>150<td>    ///   Exception raised unconditionally.
<tr class="nocodegen"><td>151<td>    /// &lt;/exception&gt;
<tr class="nocodegen"><td>152<td>    procedure ReportInvalidMessageLength(Cipher: TDECCipher);
<tr class="nocodegen"><td>153<td>    /// &lt;summary&gt;
<tr class="nocodegen"><td>154<td>    ///   Allows to run code after the initialization vector has been initialized
<tr class="nocodegen"><td>155<td>    ///   inside the Init call, which is after DoInit has been called.
<tr class="nocodegen"><td>156<td>    /// &lt;/summary&gt;
<tr class="nocodegen"><td>157<td>    /// &lt;param name=&quot;OriginalInitVector&quot;&gt;
<tr class="nocodegen"><td>158<td>    ///   Value of the init vector as originally passed to the Init call without
<tr class="nocodegen"><td>159<td>    ///   any initialization steps done to/on it
<tr class="nocodegen"><td>160<td>    /// &lt;/param&gt;
<tr class="nocodegen"><td>161<td>    procedure OnAfterInitVectorInitialization(const OriginalInitVector: TBytes); override;
<tr class="nocodegen"><td>162<td>    /// &lt;summary&gt;
<tr class="nocodegen"><td>163<td>    ///   Electronic Code Book
<tr class="nocodegen"><td>164<td>    ///   Mode cmECBx needs message padding to be a multiple of Cipher.BlockSize
<tr class="nocodegen"><td>165<td>    ///   and should be used only in 1-byte Streamciphers.
<tr class="nocodegen"><td>166<td>    ///   This one works on Blocks of Cipher.BufferSize bytes, when using a
<tr class="nocodegen"><td>167<td>    ///   Blockcipher that's equal to Cipher.BlockSize.
<tr class="nocodegen"><td>168<td>    /// &lt;/summary&gt;
<tr class="nocodegen"><td>169<td>    /// &lt;remarks&gt;
<tr class="nocodegen"><td>170<td>    ///   This mode should not be used in practice, as it makes the encrypted
<tr class="nocodegen"><td>171<td>    ///   message vulnerable to certain attacks without knowing the encryption key
<tr class="nocodegen"><td>172<td>    /// &lt;/remarks&gt;
<tr class="nocodegen"><td>173<td>    procedure EncodeECBx(Source, Dest: PByteArray; Size: Integer); virtual;
<tr class="nocodegen"><td>174<td>    /// &lt;summary&gt;
<tr class="nocodegen"><td>175<td>    ///   8bit Output Feedback mode, needs no padding
<tr class="nocodegen"><td>176<td>    /// &lt;/summary&gt;
<tr class="nocodegen"><td>177<td>    procedure EncodeOFB8(Source, Dest: PByteArray; Size: Integer); virtual;
<tr class="nocodegen"><td>178<td>    /// &lt;summary&gt;
<tr class="nocodegen"><td>179<td>    ///   8 bit Cipher Feedback mode, needs no padding and works on 8 bit
<tr class="nocodegen"><td>180<td>    ///   Feedback Shift Registers.
<tr class="nocodegen"><td>181<td>    /// &lt;/summary&gt;
<tr class="nocodegen"><td>182<td>    procedure EncodeCFB8(Source, Dest: PByteArray; Size: Integer); virtual;
<tr class="nocodegen"><td>183<td>    /// &lt;summary&gt;
<tr class="nocodegen"><td>184<td>    ///   8Bit CFS, double Cipher Feedback mode (CFB), needs no padding and
<tr class="nocodegen"><td>185<td>    ///   works on 8 bit Feedback Shift Registers.
<tr class="nocodegen"><td>186<td>    ///   This one is a proprietary mode developed by Hagen Reddmann. This mode
<tr class="nocodegen"><td>187<td>    ///   works as cmCBCx, cmCFBx, cmCFB8 but with double XOR'ing of the
<tr class="nocodegen"><td>188<td>    ///   inputstream into Feedback register.
<tr class="nocodegen"><td>189<td>    /// &lt;/summary&gt;
<tr class="nocodegen"><td>190<td>    procedure EncodeCFS8(Source, Dest: PByteArray; Size: Integer); virtual;
<tr class="nocodegen"><td>191<td>    /// &lt;summary&gt;
<tr class="nocodegen"><td>192<td>    ///   Cipher Feedback mode (CFB) on Blocksize of Cipher, needs no padding
<tr class="nocodegen"><td>193<td>    ///   This one works on Blocks of Cipher.BufferSize bytes, when using a
<tr class="nocodegen"><td>194<td>    ///   Blockcipher that's equal to Cipher.BlockSize.
<tr class="nocodegen"><td>195<td>    /// &lt;/summary&gt;
<tr class="nocodegen"><td>196<td>    procedure EncodeCFBx(Source, Dest: PByteArray; Size: Integer); virtual;
<tr class="nocodegen"><td>197<td>    /// &lt;summary&gt;
<tr class="nocodegen"><td>198<td>    ///   Output Feedback mode on Blocksize of Cipher, needs no padding and
<tr class="nocodegen"><td>199<td>    ///   works on 8 bit Feedback Shift Registers.
<tr class="nocodegen"><td>200<td>    ///   This one works on Blocks of Cipher.BufferSize bytes, when using a
<tr class="nocodegen"><td>201<td>    ///   Blockcipher that's equal to Cipher.BlockSize.
<tr class="nocodegen"><td>202<td>    /// &lt;/summary&gt;
<tr class="nocodegen"><td>203<td>    procedure EncodeOFBx(Source, Dest: PByteArray; Size: Integer); virtual;
<tr class="nocodegen"><td>204<td>    /// &lt;summary&gt;
<tr class="nocodegen"><td>205<td>    ///   double Cipher Feedback mode (CFB) on Blocksize of Cipher, needs no padding.
<tr class="nocodegen"><td>206<td>    ///   This one works on Blocks of Cipher.BufferSize bytes, when using a
<tr class="nocodegen"><td>207<td>    ///   Blockcipher that's equal to Cipher.BlockSize.
<tr class="nocodegen"><td>208<td>    ///   This one is a proprietary mode developed by Hagen Reddmann. This mode
<tr class="nocodegen"><td>209<td>    ///   works as cmCBCx, cmCFBx, cmCFB8 but with double XOR'ing of the
<tr class="nocodegen"><td>210<td>    ///   inputstream into Feedback register.
<tr class="nocodegen"><td>211<td>    /// &lt;/summary&gt;
<tr class="nocodegen"><td>212<td>    procedure EncodeCFSx(Source, Dest: PByteArray; Size: Integer); virtual;
<tr class="nocodegen"><td>213<td>    /// &lt;summary&gt;
<tr class="nocodegen"><td>214<td>    ///   Cipher Block Chaining, with CFB8 padding of truncated final block
<tr class="nocodegen"><td>215<td>    ///   It needs no external padding, because internally the last
<tr class="nocodegen"><td>216<td>    ///   truncated block is padded by cmCFS8 or cmCFB8. After padding these Modes
<tr class="nocodegen"><td>217<td>    ///   cannot be used to process any more data. If needed to process chunks of
<tr class="nocodegen"><td>218<td>    ///   data then each chunk must be aligned to Cipher.BufferSize bytes.
<tr class="nocodegen"><td>219<td>    ///   This one works on Blocks of Cipher.BufferSize bytes, when using a
<tr class="nocodegen"><td>220<td>    ///   Blockcipher that's equal to Cipher.BlockSize.
<tr class="nocodegen"><td>221<td>    /// &lt;/summary&gt;
<tr class="nocodegen"><td>222<td>    procedure EncodeCBCx(Source, Dest: PByteArray; Size: Integer); virtual;
<tr class="nocodegen"><td>223<td>    /// &lt;summary&gt;
<tr class="nocodegen"><td>224<td>    ///   double CBC, with CFS8 padding of truncated final block
<tr class="nocodegen"><td>225<td>    ///   It needs no external padding, because internally the last
<tr class="nocodegen"><td>226<td>    ///   truncated block is padded by cmCFS8 or cmCFB8. After padding these Modes
<tr class="nocodegen"><td>227<td>    ///   cannot be used to process any more data. If needed to process chunks of
<tr class="nocodegen"><td>228<td>    ///   data then each chunk must be aligned to Cipher.BufferSize bytes.
<tr class="nocodegen"><td>229<td>    ///   This one works on Blocks of Cipher.BufferSize bytes, when using a
<tr class="nocodegen"><td>230<td>    ///   Blockcipher that's equal to Cipher.BlockSize.
<tr class="nocodegen"><td>231<td>    ///   This one is a proprietary mode developed by Hagen Reddmann. This mode
<tr class="nocodegen"><td>232<td>    ///   works as cmCBCx, cmCFBx, cmCFB8 but with double XOR'ing of the
<tr class="nocodegen"><td>233<td>    ///   inputstream into Feedback register.
<tr class="nocodegen"><td>234<td>    /// &lt;/summary&gt;
<tr class="nocodegen"><td>235<td>    procedure EncodeCTSx(Source, Dest: PByteArray; Size: Integer); virtual;
<tr class="nocodegen"><td>236<td>    /// &lt;summary&gt;
<tr class="nocodegen"><td>237<td>    ///   Galois Counter Mode: encryption with addtional optional authentication.
<tr class="nocodegen"><td>238<td>    ///   Implemented in its own unit, but needed here to be callable even if
<tr class="nocodegen"><td>239<td>    ///   source length is 0.
<tr class="nocodegen"><td>240<td>    /// &lt;/summary&gt;
<tr class="nocodegen"><td>241<td>    procedure EncodeGCM(Source, Dest: PByteArray; Size: Integer); virtual;
<tr class="nocodegen"><td>242<td>    {$IFDEF DEC3_CMCTS}
<tr class="nocodegen"><td>243<td>    /// &lt;summary&gt;
<tr class="nocodegen"><td>244<td>    ///   double CBC, with
<tr class="nocodegen"><td>245<td>    ///   for DEC 3.0 compatibility only
<tr class="nocodegen"><td>246<td>    ///   This is a proprietary mode developed by Frederik Winkelsdorf. It
<tr class="nocodegen"><td>247<td>    ///   replaces the CFS8 padding of the truncated final block with a CFSx padding.
<tr class="nocodegen"><td>248<td>    ///   Useful when converting projects that previously used the old DEC v3.0. It
<tr class="nocodegen"><td>249<td>    ///   has the same restrictions for external padding and chunk processing as
<tr class="nocodegen"><td>250<td>    ///   cmCTSx has. It has a less secure padding of the truncated final block.
<tr class="nocodegen"><td>251<td>    ///   (to enable it see DECOptions.inc)
<tr class="nocodegen"><td>252<td>    /// &lt;/summary&gt;
<tr class="nocodegen"><td>253<td>    procedure EncodeCTS3(Source, Dest: PByteArray; Size: Integer); virtual;
<tr class="nocodegen"><td>254<td>    {$ENDIF}
<tr class="nocodegen"><td>255<td>    /// &lt;summary&gt;
<tr class="nocodegen"><td>256<td>    ///   Electronic Code Book
<tr class="nocodegen"><td>257<td>    ///   Mode cmECBx needs message padding to be a multiple of Cipher.BlockSize
<tr class="nocodegen"><td>258<td>    ///   and should be used only in 1-byte Streamciphers.
<tr class="nocodegen"><td>259<td>    ///   This one works on blocks of Cipher.BufferSize bytes, when using a
<tr class="nocodegen"><td>260<td>    ///   blockcipher that's equal to Cipher.BlockSize.
<tr class="nocodegen"><td>261<td>    /// &lt;/summary&gt;
<tr class="nocodegen"><td>262<td>    procedure DecodeECBx(Source, Dest: PByteArray; Size: Integer); virtual;
<tr class="nocodegen"><td>263<td>    /// &lt;summary&gt;
<tr class="nocodegen"><td>264<td>    ///   8 bit Output Feedback mode, needs no padding
<tr class="nocodegen"><td>265<td>    /// &lt;/summary&gt;
<tr class="nocodegen"><td>266<td>    procedure DecodeOFB8(Source, Dest: PByteArray; Size: Integer); virtual;
<tr class="nocodegen"><td>267<td>    /// &lt;summary&gt;
<tr class="nocodegen"><td>268<td>    ///   8 bit Cipher Feedback mode, needs no padding and works on 8 bit
<tr class="nocodegen"><td>269<td>    ///   Feedback Shift Registers.
<tr class="nocodegen"><td>270<td>    /// &lt;/summary&gt;
<tr class="nocodegen"><td>271<td>    procedure DecodeCFB8(Source, Dest: PByteArray; Size: Integer); virtual;
<tr class="nocodegen"><td>272<td>    /// &lt;summary&gt;
<tr class="nocodegen"><td>273<td>    ///   8 Bit CFS, double Cipher Feedback mode (CFB), needs no padding and
<tr class="nocodegen"><td>274<td>    ///   works on 8 bit Feedback Shift Registers.
<tr class="nocodegen"><td>275<td>    ///   This one is a proprietary mode developed by Hagen Reddmann. This mode
<tr class="nocodegen"><td>276<td>    ///   works as cmCBCx, cmCFBx, cmCFB8 but with double XOR'ing of the
<tr class="nocodegen"><td>277<td>    ///   inputstream into Feedback register.
<tr class="nocodegen"><td>278<td>    /// &lt;/summary&gt;
<tr class="nocodegen"><td>279<td>    procedure DecodeCFS8(Source, Dest: PByteArray; Size: Integer); virtual;
<tr class="nocodegen"><td>280<td>    /// &lt;summary&gt;
<tr class="nocodegen"><td>281<td>    ///   Cipher Feedback mode (CFB) on Blocksize of Cipher, needs no padding
<tr class="nocodegen"><td>282<td>    ///   This one works on blocks of Cipher.BufferSize bytes, when using a
<tr class="nocodegen"><td>283<td>    ///   blockcipher that's equal to Cipher.BlockSize.
<tr class="nocodegen"><td>284<td>    /// &lt;/summary&gt;
<tr class="nocodegen"><td>285<td>    procedure DecodeCFBx(Source, Dest: PByteArray; Size: Integer); virtual;
<tr class="nocodegen"><td>286<td>    /// &lt;summary&gt;
<tr class="nocodegen"><td>287<td>    ///   Output Feedback mode on Blocksize of Cipher, needs no padding and
<tr class="nocodegen"><td>288<td>    ///   works on 8 bit Feedback Shift Registers.
<tr class="nocodegen"><td>289<td>    ///   This one works on blocks of Cipher.BufferSize bytes, when using a
<tr class="nocodegen"><td>290<td>    ///   blockcipher that's equal to Cipher.BlockSize.
<tr class="nocodegen"><td>291<td>    /// &lt;/summary&gt;
<tr class="nocodegen"><td>292<td>    procedure DecodeOFBx(Source, Dest: PByteArray; Size: Integer); virtual;
<tr class="nocodegen"><td>293<td>    /// &lt;summary&gt;
<tr class="nocodegen"><td>294<td>    ///   double Cipher Feedback mode (CFB) on Blocksize of Cipher, needs no padding.
<tr class="nocodegen"><td>295<td>    ///   This one works on blocks of Cipher.BufferSize bytes, when using a
<tr class="nocodegen"><td>296<td>    ///   blockcipher that's equal to Cipher.BlockSize.
<tr class="nocodegen"><td>297<td>    ///   This one is a proprietary mode developed by Hagen Reddmann. This mode
<tr class="nocodegen"><td>298<td>    ///   works as cmCBCx, cmCFBx, cmCFB8 but with double XOR'ing of the
<tr class="nocodegen"><td>299<td>    ///   inputstream into Feedback register.
<tr class="nocodegen"><td>300<td>    /// &lt;/summary&gt;
<tr class="nocodegen"><td>301<td>    procedure DecodeCFSx(Source, Dest: PByteArray; Size: Integer); virtual;
<tr class="nocodegen"><td>302<td>    /// &lt;summary&gt;
<tr class="nocodegen"><td>303<td>    ///   Cipher Block Chaining, with CFB8 padding of truncated final block.
<tr class="nocodegen"><td>304<td>    ///   It needs no external padding, because internally the last
<tr class="nocodegen"><td>305<td>    ///   truncated block is padded by cmCFS8 or cmCFB8. After padding these modes
<tr class="nocodegen"><td>306<td>    ///   cannot be used to process any more data. If needed to process chunks of
<tr class="nocodegen"><td>307<td>    ///   data then each chunk must be algined to Cipher.BufferSize bytes.
<tr class="nocodegen"><td>308<td>    ///   This one works on blocks of Cipher.BufferSize bytes, when using a
<tr class="nocodegen"><td>309<td>    ///   blockcipher that's equal to Cipher.BlockSize.
<tr class="nocodegen"><td>310<td>    /// &lt;/summary&gt;
<tr class="nocodegen"><td>311<td>    procedure DecodeCBCx(Source, Dest: PByteArray; Size: Integer); virtual;
<tr class="nocodegen"><td>312<td>    /// &lt;summary&gt;
<tr class="nocodegen"><td>313<td>    ///   double CBC, with CFS8 padding of truncated final block
<tr class="nocodegen"><td>314<td>    ///   It needs no external padding, because internally the last
<tr class="nocodegen"><td>315<td>    ///   truncated block is padded by cmCFS8 or cmCFB8. After padding these Modes
<tr class="nocodegen"><td>316<td>    ///   cannot be used to process any more data. If needed to process chunks of
<tr class="nocodegen"><td>317<td>    ///   data then each chunk must be algined to Cipher.BufferSize bytes.
<tr class="nocodegen"><td>318<td>    ///   This one works on blocks of Cipher.BufferSize bytes, when using a
<tr class="nocodegen"><td>319<td>    ///   blockcipher that's equal to Cipher.BlockSize.
<tr class="nocodegen"><td>320<td>    ///   This one is a proprietary mode developed by Hagen Reddmann. This mode
<tr class="nocodegen"><td>321<td>    ///   works as cmCBCx, cmCFBx, cmCFB8 but with double XOR'ing of the
<tr class="nocodegen"><td>322<td>    ///   inputstream into feedback register.
<tr class="nocodegen"><td>323<td>    /// &lt;/summary&gt;
<tr class="nocodegen"><td>324<td>    procedure DecodeCTSx(Source, Dest: PByteArray; Size: Integer); virtual;
<tr class="nocodegen"><td>325<td>    /// &lt;summary&gt;
<tr class="nocodegen"><td>326<td>    ///   Galois Counter Mode, details are implemented in DECCipherModesGCM
<tr class="nocodegen"><td>327<td>    /// &lt;/summary&gt;
<tr class="nocodegen"><td>328<td>    procedure DecodeGCM(Source, Dest: PByteArray; Size: Integer); virtual;
<tr class="nocodegen"><td>329<td>    {$IFDEF DEC3_CMCTS}
<tr class="nocodegen"><td>330<td>    /// &lt;summary&gt;
<tr class="nocodegen"><td>331<td>    ///   double CBC
<tr class="nocodegen"><td>332<td>    ///   This is a proprietary mode developed by Frederik Winkelsdorf. It
<tr class="nocodegen"><td>333<td>    ///   replaces the CFS8 padding of the truncated final block with a CFSx padding.
<tr class="nocodegen"><td>334<td>    ///   Useful when converting projects that previously used the old DEC v3.0. It
<tr class="nocodegen"><td>335<td>    ///   has the same restrictions for external padding and chunk processing as
<tr class="nocodegen"><td>336<td>    ///   cmCTSx has. It has a less secure padding of the truncated final block.
<tr class="nocodegen"><td>337<td>    ///   (to enable it see DECOptions.inc)
<tr class="nocodegen"><td>338<td>    /// &lt;/summary&gt;
<tr class="nocodegen"><td>339<td>    /// &lt;remarks&gt;
<tr class="nocodegen"><td>340<td>    ///   For DEC 3.0 compatibility only
<tr class="nocodegen"><td>341<td>    /// &lt;/remarks&gt;
<tr class="nocodegen"><td>342<td>    procedure DecodeCTS3(Source, Dest: PByteArray; Size: Integer); virtual;
<tr class="nocodegen"><td>343<td>    {$ENDIF}
<tr class="nocodegen"><td>344<td>    /// &lt;summary&gt;
<tr class="nocodegen"><td>345<td>    ///   When setting mode to GCM the GCM implementing class instance needs to
<tr class="nocodegen"><td>346<td>    ///   be created
<tr class="nocodegen"><td>347<td>    /// &lt;/summary&gt;
<tr class="nocodegen"><td>348<td>    procedure InitMode; override;
<tr class="nocodegen"><td>349<td>  public
<tr class="nocodegen"><td>350<td>    /// &lt;summary&gt;
<tr class="nocodegen"><td>351<td>    ///   Frees, if necessary, internal objects
<tr class="nocodegen"><td>352<td>    /// &lt;/summary&gt;
<tr class="nocodegen"><td>353<td>    destructor Destroy; override;
<tr class="nocodegen"><td>354<td>    /// &lt;summary&gt;
<tr class="nocodegen"><td>355<td>    ///   Encrypts a given block of data
<tr class="nocodegen"><td>356<td>    /// &lt;/summary&gt;
<tr class="nocodegen"><td>357<td>    /// &lt;param name=&quot;Source&quot;&gt;
<tr class="nocodegen"><td>358<td>    ///   Data to be encrypted
<tr class="nocodegen"><td>359<td>    /// &lt;/param&gt;
<tr class="nocodegen"><td>360<td>    /// &lt;param name=&quot;Dest&quot;&gt;
<tr class="nocodegen"><td>361<td>    ///   Data after encryption
<tr class="nocodegen"><td>362<td>    /// &lt;/param&gt;
<tr class="nocodegen"><td>363<td>    /// &lt;param name=&quot;DataSize&quot;&gt;
<tr class="nocodegen"><td>364<td>    ///   Size of the data the Source parameter points to in byte
<tr class="nocodegen"><td>365<td>    /// &lt;/param&gt;
<tr class="nocodegen"><td>366<td>    procedure Encode(const Source; var Dest; DataSize: Integer);
<tr class="nocodegen"><td>367<td>    /// &lt;summary&gt;
<tr class="nocodegen"><td>368<td>    ///   Decrypts a given block of data
<tr class="nocodegen"><td>369<td>    /// &lt;/summary&gt;
<tr class="nocodegen"><td>370<td>    /// &lt;param name=&quot;Source&quot;&gt;
<tr class="nocodegen"><td>371<td>    ///   Data to be Decrypted
<tr class="nocodegen"><td>372<td>    /// &lt;/param&gt;
<tr class="nocodegen"><td>373<td>    /// &lt;param name=&quot;Dest&quot;&gt;
<tr class="nocodegen"><td>374<td>    ///   Data after decryption
<tr class="nocodegen"><td>375<td>    /// &lt;/param&gt;
<tr class="nocodegen"><td>376<td>    /// &lt;param name=&quot;DataSize&quot;&gt;
<tr class="nocodegen"><td>377<td>    ///   Size of the data the Source parameter points to in byte
<tr class="nocodegen"><td>378<td>    /// &lt;/param&gt;
<tr class="nocodegen"><td>379<td>    procedure Decode(const Source; var Dest; DataSize: Integer);
<tr class="nocodegen"><td>380<td>
<tr class="nocodegen"><td>381<td>    /// &lt;summary&gt;
<tr class="nocodegen"><td>382<td>    ///   Properly finishes the cryptographic operation. It needs to be called
<tr class="nocodegen"><td>383<td>    ///   at the end of encrypting or decrypting data, otherwise the last block
<tr class="nocodegen"><td>384<td>    ///   or last byte of the data will not be properly processed.
<tr class="nocodegen"><td>385<td>    /// &lt;/summary&gt;
<tr class="nocodegen"><td>386<td>    procedure Done; override;
<tr class="nocodegen"><td>387<td>
<tr class="nocodegen"><td>388<td>    /// &lt;summary&gt;
<tr class="nocodegen"><td>389<td>    ///   Returns a list of CalculatedAuthenticationResult lengths explicitely
<tr class="nocodegen"><td>390<td>    ///   specified by the official specification of the standard.
<tr class="nocodegen"><td>391<td>    /// &lt;/summary&gt;
<tr class="nocodegen"><td>392<td>    /// &lt;returns&gt;
<tr class="nocodegen"><td>393<td>    ///   List of bit lengths. If the cipher mode used is not an authenticated
<tr class="nocodegen"><td>394<td>    ///   one, the array will just contain a single value of 0.
<tr class="nocodegen"><td>395<td>    /// &lt;/returns&gt;
<tr class="nocodegen"><td>396<td>    function GetStandardAuthenticationTagBitLengths:TStandardBitLengths;
<tr class="nocodegen"><td>397<td>
<tr class="nocodegen"><td>398<td>    /// &lt;summary&gt;
<tr class="nocodegen"><td>399<td>    ///   Some block chaining modes have the ability to authenticate the message
<tr class="nocodegen"><td>400<td>    ///   in addition to encrypting it. This property contains the data which
<tr class="nocodegen"><td>401<td>    ///   shall be authenticated in parallel to the encryption. Some authenticated
<tr class="nocodegen"><td>402<td>    ///   modes still generate an authentication result even if no additional
<tr class="nocodegen"><td>403<td>    ///   data is supplied via this property, e.g. cmGCM is one of those.
<tr class="nocodegen"><td>404<td>    /// &lt;/summary&gt;
<tr class="nocodegen"><td>405<td>    property DataToAuthenticate : TBytes
<tr class="nocodegen"><td>406<td>      read   GetDataToAuthenticate
<tr class="nocodegen"><td>407<td>      write  SetDataToAuthenticate;
<tr class="nocodegen"><td>408<td>
<tr class="nocodegen"><td>409<td>    /// &lt;summary&gt;
<tr class="nocodegen"><td>410<td>    ///   Some block chaining modes have the ability to authenticate the message
<tr class="nocodegen"><td>411<td>    ///   in addition to encrypting it.
<tr class="nocodegen"><td>412<td>    ///   Represents the length of CalculatedAuthenticationResult in bit, values
<tr class="nocodegen"><td>413<td>    ///   as per specification are: 128, 120, 112, 104, or 96 bit. For certain
<tr class="nocodegen"><td>414<td>    ///   applications, they may be 64 or 32 as well, but the use of these two
<tr class="nocodegen"><td>415<td>    ///   tag lengths constrains the length of the input data and the lifetime
<tr class="nocodegen"><td>416<td>    ///   of the key.
<tr class="nocodegen"><td>417<td>    /// &lt;/summary&gt;
<tr class="nocodegen"><td>418<td>    property AuthenticationResultBitLength : Integer
<tr class="nocodegen"><td>419<td>      read   GetAuthenticationResultBitLength
<tr class="nocodegen"><td>420<td>      write  SetAuthenticationResultBitLength;
<tr class="nocodegen"><td>421<td>    /// &lt;summary&gt;
<tr class="nocodegen"><td>422<td>    ///   Some block chaining modes have the ability to authenticate the message
<tr class="nocodegen"><td>423<td>    ///   in addition to encrypting it. This property contains the generated
<tr class="nocodegen"><td>424<td>    ///   authentication tag. Raises an EDECCipherException if this is
<tr class="nocodegen"><td>425<td>    ///   called for a cipher mode not supporting authentication.
<tr class="nocodegen"><td>426<td>    /// &lt;/summary&gt;
<tr class="nocodegen"><td>427<td>    /// &lt;exception cref=&quot;EDECCipherException&quot;&gt;
<tr class="nocodegen"><td>428<td>    ///   Exception raised if called for a cipher mode not supporting
<tr class="nocodegen"><td>429<td>    ///   authentication.
<tr class="nocodegen"><td>430<td>    /// &lt;/exception&gt;
<tr class="nocodegen"><td>431<td>    property CalculatedAuthenticationResult  : TBytes
<tr class="nocodegen"><td>432<td>      read   GetCalcAuthenticatonResult;
<tr class="nocodegen"><td>433<td>
<tr class="nocodegen"><td>434<td>    /// &lt;summary&gt;
<tr class="nocodegen"><td>435<td>    ///   Expected CalculatedAuthenticationResult value, will be compared with
<tr class="nocodegen"><td>436<td>    ///   actual value when decryption finished. Raises an EDECCipherException
<tr class="nocodegen"><td>437<td>    ///   if this is called for a cipher mode not supporting authentication.
<tr class="nocodegen"><td>438<td>    /// &lt;/summary&gt;
<tr class="nocodegen"><td>439<td>    /// &lt;exception cref=&quot;EDECCipherException&quot;&gt;
<tr class="nocodegen"><td>440<td>    ///   Exception raised if called for a cipher mode not supporting
<tr class="nocodegen"><td>441<td>    ///   authentication.
<tr class="nocodegen"><td>442<td>    /// &lt;/exception&gt;
<tr class="nocodegen"><td>443<td>    property ExpectedAuthenticationResult : TBytes
<tr class="nocodegen"><td>444<td>      read   GetExpectedAuthenticationResult
<tr class="nocodegen"><td>445<td>      write  SetExpectedAuthenticationResult;
<tr class="nocodegen"><td>446<td>  end;
<tr class="nocodegen"><td>447<td>
<tr class="nocodegen"><td>448<td>implementation
<tr class="nocodegen"><td>449<td>
<tr class="nocodegen"><td>450<td>uses
<tr class="nocodegen"><td>451<td>  {$IFDEF FPC}
<tr class="nocodegen"><td>452<td>  TypInfo,
<tr class="nocodegen"><td>453<td>  {$ELSE}
<tr class="nocodegen"><td>454<td>  System.TypInfo,
<tr class="nocodegen"><td>455<td>  {$ENDIF}
<tr class="nocodegen"><td>456<td>  DECUtil;
<tr class="nocodegen"><td>457<td>
<tr class="nocodegen"><td>458<td>resourcestring
<tr class="nocodegen"><td>459<td>  sInvalidMessageLength = 'Message length for mode %0:s must be a multiple of %1:d bytes';
<tr class="nocodegen"><td>460<td>  sInvalidBlockSize     = 'Block size must be %0:d bit for selected mode %1:s';
<tr class="nocodegen"><td>461<td>  sInvalidModeForMethod = 'Invalid mode for this method. Mode must be %0:s';
<tr class="nocodegen"><td>462<td>
<tr class="nocodegen"><td>463<td>  /// &lt;summary&gt;
<tr class="nocodegen"><td>464<td>  ///   Exception message when calculated authentication value does not match
<tr class="nocodegen"><td>465<td>  ///   given expected one
<tr class="nocodegen"><td>466<td>  /// &lt;/summary&gt;
<tr class="nocodegen"><td>467<td>  sInvalidAuthenticationValue = 'Calculated authentication value does not match '+
<tr class="nocodegen"><td>468<td>                                'given expected value';
<tr class="nocodegen"><td>469<td>
<tr class="nocodegen"><td>470<td>procedure TDECCipherModes.ReportInvalidMessageLength(Cipher: TDECCipher);
<tr class="covered"><td>471<td>begin
<tr class="covered"><td>472<td>  raise EDECCipherException.CreateResFmt(@sInvalidMessageLength,
<tr class="nocodegen"><td>473<td>                                         [System.TypInfo.GetEnumName(TypeInfo(TCipherMode),
<tr class="nocodegen"><td>474<td>                                         Integer(Cipher.Mode)),
<tr class="nocodegen"><td>475<td>                                         Cipher.Context.BlockSize]);
<tr class="notcovered"><td>476<td>end;
<tr class="nocodegen"><td>477<td>
<tr class="nocodegen"><td>478<td>procedure TDECCipherModes.SetDataToAuthenticate(const Value: TBytes);
<tr class="covered"><td>479<td>begin
<tr class="covered"><td>480<td>  if (FMode = cmGCM) then
<tr class="covered"><td>481<td>    FGCM.DataToAuthenticate := Value
<tr class="nocodegen"><td>482<td>  else
<tr class="covered"><td>483<td>    raise EDECCipherException.CreateResFmt(@sInvalidModeForMethod, ['cmGCM']);
<tr class="covered"><td>484<td>end;
<tr class="nocodegen"><td>485<td>
<tr class="nocodegen"><td>486<td>procedure TDECCipherModes.SetExpectedAuthenticationResult(const Value: TBytes);
<tr class="covered"><td>487<td>begin
<tr class="covered"><td>488<td>  if (FMode = cmGCM) then
<tr class="covered"><td>489<td>    FGCM.ExpectedAuthenticationTag := Value
<tr class="nocodegen"><td>490<td>  else
<tr class="covered"><td>491<td>    raise EDECCipherException.CreateResFmt(@sInvalidModeForMethod, ['cmGCM']);
<tr class="covered"><td>492<td>end;
<tr class="nocodegen"><td>493<td>
<tr class="nocodegen"><td>494<td>procedure TDECCipherModes.SetAuthenticationResultBitLength(
<tr class="nocodegen"><td>495<td>  const Value: Integer);
<tr class="covered"><td>496<td>begin
<tr class="covered"><td>497<td>  if (FMode = cmGCM) then
<tr class="covered"><td>498<td>    FGCM.AuthenticationTagBitLength := Value
<tr class="nocodegen"><td>499<td>  else
<tr class="covered"><td>500<td>    raise EDECCipherException.CreateResFmt(@sInvalidModeForMethod, ['cmGCM']);
<tr class="covered"><td>501<td>end;
<tr class="nocodegen"><td>502<td>
<tr class="nocodegen"><td>503<td>procedure TDECCipherModes.Encode(const Source; var Dest; DataSize: Integer);
<tr class="covered"><td>504<td>begin
<tr class="covered"><td>505<td>  CheckState([csInitialized, csEncode, csDone]);
<tr class="nocodegen"><td>506<td>
<tr class="covered"><td>507<td>  case FMode of
<tr class="covered"><td>508<td>    cmECBx:   EncodeECBx(@Source, @Dest, DataSize);
<tr class="covered"><td>509<td>    cmCBCx:   EncodeCBCx(@Source, @Dest, DataSize);
<tr class="covered"><td>510<td>    cmCTSx:   EncodeCTSx(@Source, @Dest, DataSize);
<tr class="nocodegen"><td>511<td>    {$IFDEF DEC3_CMCTS}
<tr class="nocodegen"><td>512<td>    cmCTS3:   EncodeCTS3(@Source, @Dest, DataSize);
<tr class="nocodegen"><td>513<td>    {$ENDIF DEC3_CMCTS}
<tr class="covered"><td>514<td>    cmCFB8:   EncodeCFB8(@Source, @Dest, DataSize);
<tr class="covered"><td>515<td>    cmCFBx:   EncodeCFBx(@Source, @Dest, DataSize);
<tr class="covered"><td>516<td>    cmOFB8:   EncodeOFB8(@Source, @Dest, DataSize);
<tr class="covered"><td>517<td>    cmOFBx:   EncodeOFBx(@Source, @Dest, DataSize);
<tr class="covered"><td>518<td>    cmCFS8:   EncodeCFS8(@Source, @Dest, DataSize);
<tr class="covered"><td>519<td>    cmCFSx:   EncodeCFSx(@Source, @Dest, DataSize);
<tr class="covered"><td>520<td>    cmGCM :   EncodeGCM(@Source, @Dest, DataSize);
<tr class="nocodegen"><td>521<td>  end;
<tr class="covered"><td>522<td>end;
<tr class="nocodegen"><td>523<td>
<tr class="nocodegen"><td>524<td>procedure TDECCipherModes.EncodeECBx(Source, Dest: PByteArray; Size: Integer);
<tr class="nocodegen"><td>525<td>var
<tr class="nocodegen"><td>526<td>  I: Integer;
<tr class="covered"><td>527<td>begin
<tr class="covered"><td>528<td>  if Context.BlockSize = 1 then
<tr class="nocodegen"><td>529<td>  begin
<tr class="covered"><td>530<td>    DoEncode(Source, Dest, Size);
<tr class="covered"><td>531<td>    FState := csEncode;
<tr class="nocodegen"><td>532<td>  end
<tr class="nocodegen"><td>533<td>  else
<tr class="nocodegen"><td>534<td>  begin
<tr class="covered"><td>535<td>    Dec(Size, FBufferSize);
<tr class="covered"><td>536<td>    I := 0;
<tr class="covered"><td>537<td>    while I &lt;= Size do
<tr class="nocodegen"><td>538<td>    begin
<tr class="covered"><td>539<td>      DoEncode(@Source[I], @Dest[I], FBufferSize);
<tr class="covered"><td>540<td>      Inc(I, FBufferSize);
<tr class="nocodegen"><td>541<td>    end;
<tr class="covered"><td>542<td>    Dec(Size, I - FBufferSize);
<tr class="covered"><td>543<td>    if Size &gt; 0 then
<tr class="nocodegen"><td>544<td>    begin
<tr class="covered"><td>545<td>      if Size mod Context.BlockSize = 0 then
<tr class="nocodegen"><td>546<td>      begin
<tr class="covered"><td>547<td>        DoEncode(@Source[I], @Dest[I], Size);
<tr class="covered"><td>548<td>        FState := csEncode;
<tr class="nocodegen"><td>549<td>      end
<tr class="nocodegen"><td>550<td>      else
<tr class="nocodegen"><td>551<td>      begin
<tr class="covered"><td>552<td>        FState := csPadded;
<tr class="covered"><td>553<td>        ReportInvalidMessageLength(Self);
<tr class="nocodegen"><td>554<td>      end;
<tr class="nocodegen"><td>555<td>    end;
<tr class="nocodegen"><td>556<td>  end;
<tr class="covered"><td>557<td>end;
<tr class="nocodegen"><td>558<td>
<tr class="nocodegen"><td>559<td>procedure TDECCipherModes.EncodeOFB8(Source, Dest: PByteArray; Size: Integer);
<tr class="nocodegen"><td>560<td>var
<tr class="nocodegen"><td>561<td>  I: Integer;
<tr class="covered"><td>562<td>begin
<tr class="covered"><td>563<td>  I := 0;
<tr class="covered"><td>564<td>  while I &lt; Size do
<tr class="nocodegen"><td>565<td>  begin
<tr class="covered"><td>566<td>    DoEncode(FFeedback, FBuffer, FBufferSize);
<tr class="covered"><td>567<td>    Move(FFeedback[1], FFeedback[0], FBufferSize - 1);
<tr class="covered"><td>568<td>    FFeedback[FBufferSize - 1] := FBuffer[0];
<tr class="covered"><td>569<td>    Dest[I] := Source[I] xor FBuffer[0];
<tr class="covered"><td>570<td>    Inc(I);
<tr class="nocodegen"><td>571<td>  end;
<tr class="covered"><td>572<td>  FState := csEncode;
<tr class="covered"><td>573<td>end;
<tr class="nocodegen"><td>574<td>
<tr class="nocodegen"><td>575<td>procedure TDECCipherModes.EncodeCFB8(Source, Dest: PByteArray; Size: Integer);
<tr class="nocodegen"><td>576<td>// CFB-8
<tr class="nocodegen"><td>577<td>var
<tr class="nocodegen"><td>578<td>  I: Integer;
<tr class="covered"><td>579<td>begin
<tr class="covered"><td>580<td>  I := 0;
<tr class="covered"><td>581<td>  while I &lt; Size do
<tr class="nocodegen"><td>582<td>  begin
<tr class="covered"><td>583<td>    DoEncode(FFeedback, FBuffer, FBufferSize);
<tr class="covered"><td>584<td>    Move(FFeedback[1], FFeedback[0], FBufferSize - 1);
<tr class="covered"><td>585<td>    Dest[I] := Source[I] xor FBuffer[0];
<tr class="covered"><td>586<td>    FFeedback[FBufferSize - 1] := Dest[I];
<tr class="covered"><td>587<td>    Inc(I);
<tr class="nocodegen"><td>588<td>  end;
<tr class="covered"><td>589<td>  FState := csEncode;
<tr class="covered"><td>590<td>end;
<tr class="nocodegen"><td>591<td>
<tr class="nocodegen"><td>592<td>procedure TDECCipherModes.EncodeCFS8(Source, Dest: PByteArray; Size: Integer);
<tr class="nocodegen"><td>593<td>// CFS-8, CTS as CFB
<tr class="nocodegen"><td>594<td>var
<tr class="nocodegen"><td>595<td>  I: Integer;
<tr class="covered"><td>596<td>begin
<tr class="covered"><td>597<td>  I := 0;
<tr class="covered"><td>598<td>  while I &lt; Size do
<tr class="nocodegen"><td>599<td>  begin
<tr class="covered"><td>600<td>    DoEncode(FFeedback, FBuffer, FBufferSize);
<tr class="covered"><td>601<td>    Dest[I] := Source[I] xor FBuffer[0];
<tr class="covered"><td>602<td>    Move(FFeedback[1], FFeedback[0], FBufferSize - 1);
<tr class="covered"><td>603<td>    FFeedback[FBufferSize - 1] := FFeedback[FBufferSize - 1] xor Dest[I];
<tr class="covered"><td>604<td>    Inc(I);
<tr class="nocodegen"><td>605<td>  end;
<tr class="covered"><td>606<td>  FState := csEncode;
<tr class="covered"><td>607<td>end;
<tr class="nocodegen"><td>608<td>
<tr class="nocodegen"><td>609<td>procedure TDECCipherModes.EncodeCFBx(Source, Dest: PByteArray; Size: Integer);
<tr class="nocodegen"><td>610<td>// CFB-BlockSize
<tr class="nocodegen"><td>611<td>var
<tr class="nocodegen"><td>612<td>  I: Integer;
<tr class="nocodegen"><td>613<td>  F: PByteArray;
<tr class="covered"><td>614<td>begin
<tr class="covered"><td>615<td>  FState := csEncode;
<tr class="covered"><td>616<td>  if FBufferIndex &gt; 0 then
<tr class="nocodegen"><td>617<td>  begin
<tr class="notcovered"><td>618<td>    I := FBufferSize - FBufferIndex;
<tr class="notcovered"><td>619<td>    if I &gt; Size then
<tr class="notcovered"><td>620<td>      I := Size;
<tr class="notcovered"><td>621<td>    XORBuffers(Source[0], FBuffer[FBufferIndex], I, Dest[0]);
<tr class="notcovered"><td>622<td>    Move(Dest[0], FFeedback[FBufferIndex], I);
<tr class="notcovered"><td>623<td>    Inc(FBufferIndex, I);
<tr class="notcovered"><td>624<td>    if FBufferIndex &lt; FBufferSize then
<tr class="nocodegen"><td>625<td>      Exit;
<tr class="notcovered"><td>626<td>    Dec(Size, I);
<tr class="notcovered"><td>627<td>    Source := @Source[I];
<tr class="notcovered"><td>628<td>    Dest := @Dest[I];
<tr class="notcovered"><td>629<td>    FBufferIndex := 0
<tr class="nocodegen"><td>630<td>  end;
<tr class="covered"><td>631<td>  Dec(Size, FBufferSize);
<tr class="covered"><td>632<td>  F := FFeedback;
<tr class="covered"><td>633<td>  I := 0;
<tr class="covered"><td>634<td>  while I &lt; Size do
<tr class="nocodegen"><td>635<td>  begin
<tr class="covered"><td>636<td>    DoEncode(F, FBuffer, FBufferSize);
<tr class="covered"><td>637<td>    XORBuffers(Source[I], FBuffer[0], FBufferSize, Dest[I]);
<tr class="covered"><td>638<td>    F := @Dest[I];
<tr class="covered"><td>639<td>    Inc(I, FBufferSize);
<tr class="nocodegen"><td>640<td>  end;
<tr class="covered"><td>641<td>  if F &lt;&gt; FFeedback then
<tr class="covered"><td>642<td>    Move(F^, FFeedback^, FBufferSize);
<tr class="covered"><td>643<td>  Dec(Size, I - FBufferSize);
<tr class="covered"><td>644<td>  if Size &gt; 0 then
<tr class="nocodegen"><td>645<td>  begin
<tr class="covered"><td>646<td>    DoEncode(FFeedback, FBuffer, FBufferSize);
<tr class="covered"><td>647<td>    XORBuffers(Source[I], FBuffer[0], Size, Dest[I]);
<tr class="covered"><td>648<td>    Move(Dest[I], FFeedback[0], Size);
<tr class="covered"><td>649<td>    FBufferIndex := Size;
<tr class="nocodegen"><td>650<td>  end;
<tr class="covered"><td>651<td>end;
<tr class="nocodegen"><td>652<td>
<tr class="nocodegen"><td>653<td>procedure TDECCipherModes.EncodeOFBx(Source, Dest: PByteArray; Size: Integer);
<tr class="nocodegen"><td>654<td>// OFB-BlockSize
<tr class="nocodegen"><td>655<td>var
<tr class="nocodegen"><td>656<td>  I: Integer;
<tr class="covered"><td>657<td>begin
<tr class="covered"><td>658<td>  FState := csEncode;
<tr class="covered"><td>659<td>  if FBufferIndex &gt; 0 then
<tr class="nocodegen"><td>660<td>  begin
<tr class="notcovered"><td>661<td>    I := FBufferSize - FBufferIndex;
<tr class="notcovered"><td>662<td>    if I &gt; Size then
<tr class="notcovered"><td>663<td>      I := Size;
<tr class="notcovered"><td>664<td>    XORBuffers(Source[0], FFeedback[FBufferIndex], I, Dest[0]);
<tr class="notcovered"><td>665<td>    Inc(FBufferIndex, I);
<tr class="notcovered"><td>666<td>    if FBufferIndex &lt; FBufferSize then
<tr class="nocodegen"><td>667<td>      Exit;
<tr class="notcovered"><td>668<td>    Dec(Size, I);
<tr class="notcovered"><td>669<td>    Source := @Source[I];
<tr class="notcovered"><td>670<td>    Dest := @Dest[I];
<tr class="notcovered"><td>671<td>    FBufferIndex := 0
<tr class="nocodegen"><td>672<td>  end;
<tr class="covered"><td>673<td>  Dec(Size, FBufferSize);
<tr class="covered"><td>674<td>  I := 0;
<tr class="covered"><td>675<td>  while I &lt; Size do
<tr class="nocodegen"><td>676<td>  begin
<tr class="covered"><td>677<td>    DoEncode(FFeedback, FFeedback, FBufferSize);
<tr class="covered"><td>678<td>    XORBuffers(Source[I], FFeedback[0], FBufferSize, Dest[I]);
<tr class="covered"><td>679<td>    Inc(I, FBufferSize);
<tr class="nocodegen"><td>680<td>  end;
<tr class="covered"><td>681<td>  Dec(Size, I - FBufferSize);
<tr class="covered"><td>682<td>  if Size &gt; 0 then
<tr class="nocodegen"><td>683<td>  begin
<tr class="covered"><td>684<td>    DoEncode(FFeedback, FFeedback, FBufferSize);
<tr class="covered"><td>685<td>    XORBuffers(Source[I], FFeedback[0], Size, Dest[I]);
<tr class="covered"><td>686<td>    FBufferIndex := Size;
<tr class="nocodegen"><td>687<td>  end;
<tr class="covered"><td>688<td>end;
<tr class="nocodegen"><td>689<td>
<tr class="nocodegen"><td>690<td>function TDECCipherModes.GetDataToAuthenticate: TBytes;
<tr class="covered"><td>691<td>begin
<tr class="covered"><td>692<td>  if (FMode = cmGCM) then
<tr class="covered"><td>693<td>    Result := FGCM.DataToAuthenticate
<tr class="nocodegen"><td>694<td>  else
<tr class="covered"><td>695<td>    raise EDECCipherException.CreateResFmt(@sInvalidModeForMethod, ['cmGCM']);
<tr class="covered"><td>696<td>end;
<tr class="nocodegen"><td>697<td>
<tr class="nocodegen"><td>698<td>function TDECCipherModes.GetExpectedAuthenticationResult: TBytes;
<tr class="covered"><td>699<td>begin
<tr class="covered"><td>700<td>  if (FMode = cmGCM) then
<tr class="covered"><td>701<td>    Result := FGCM.ExpectedAuthenticationTag
<tr class="nocodegen"><td>702<td>  else
<tr class="covered"><td>703<td>    raise EDECCipherException.CreateResFmt(@sInvalidModeForMethod, ['cmGCM']);
<tr class="covered"><td>704<td>end;
<tr class="nocodegen"><td>705<td>
<tr class="nocodegen"><td>706<td>function TDECCipherModes.GetStandardAuthenticationTagBitLengths: TStandardBitLengths;
<tr class="covered"><td>707<td>begin
<tr class="covered"><td>708<td>  case FMode of
<tr class="covered"><td>709<td>    cmGCM: Result := FGCM.GetStandardAuthenticationTagBitLengths;
<tr class="nocodegen"><td>710<td>    else
<tr class="nocodegen"><td>711<td>    begin
<tr class="covered"><td>712<td>      SetLength(Result, 1);
<tr class="covered"><td>713<td>      Result[0] := 0;
<tr class="nocodegen"><td>714<td>    end;
<tr class="nocodegen"><td>715<td>  end;
<tr class="covered"><td>716<td>end;
<tr class="nocodegen"><td>717<td>
<tr class="nocodegen"><td>718<td>function TDECCipherModes.GetAuthenticationResultBitLength: Integer;
<tr class="covered"><td>719<td>begin
<tr class="covered"><td>720<td>  if (FMode = cmGCM) then
<tr class="covered"><td>721<td>    Result := FGCM.AuthenticationTagBitLength
<tr class="nocodegen"><td>722<td>  else
<tr class="covered"><td>723<td>    raise EDECCipherException.CreateResFmt(@sInvalidModeForMethod, ['cmGCM']);
<tr class="covered"><td>724<td>end;
<tr class="nocodegen"><td>725<td>
<tr class="nocodegen"><td>726<td>function TDECCipherModes.GetCalcAuthenticatonResult: TBytes;
<tr class="covered"><td>727<td>begin
<tr class="covered"><td>728<td>  if (FMode = cmGCM) then
<tr class="covered"><td>729<td>    Result := FGCM.CalculatedAuthenticationTag
<tr class="nocodegen"><td>730<td>  else
<tr class="covered"><td>731<td>    raise EDECCipherException.CreateResFmt(@sInvalidModeForMethod, ['cmGCM']);
<tr class="covered"><td>732<td>end;
<tr class="nocodegen"><td>733<td>
<tr class="nocodegen"><td>734<td>procedure TDECCipherModes.InitMode;
<tr class="covered"><td>735<td>begin
<tr class="covered"><td>736<td>  if FMode = TCipherMode.cmGCM then
<tr class="nocodegen"><td>737<td>  begin
<tr class="covered"><td>738<td>    if Context.BlockSize = 16 then
<tr class="covered"><td>739<td>      FGCM := TGCM.Create
<tr class="nocodegen"><td>740<td>    else
<tr class="nocodegen"><td>741<td>      // GCM requires a cipher with 128 bit block size
<tr class="covered"><td>742<td>      raise EDECCipherException.CreateResFmt(@sInvalidBlockSize,
<tr class="nocodegen"><td>743<td>                                             [128, System.TypInfo.GetEnumName(TypeInfo(TCipherMode),
<tr class="nocodegen"><td>744<td>                                             Integer(FMode))]);
<tr class="nocodegen"><td>745<td>  end
<tr class="nocodegen"><td>746<td>  else
<tr class="covered"><td>747<td>    if Assigned(FGCM) then
<tr class="notcovered"><td>748<td>      FreeAndNil(FGCM);
<tr class="covered"><td>749<td>end;
<tr class="nocodegen"><td>750<td>
<tr class="nocodegen"><td>751<td>procedure TDECCipherModes.EncodeCFSx(Source, Dest: PByteArray; Size: Integer);
<tr class="nocodegen"><td>752<td>// CFS-BlockSize
<tr class="nocodegen"><td>753<td>var
<tr class="nocodegen"><td>754<td>  I: Integer;
<tr class="covered"><td>755<td>begin
<tr class="covered"><td>756<td>  FState := csEncode;
<tr class="covered"><td>757<td>  if FBufferIndex &gt; 0 then
<tr class="nocodegen"><td>758<td>  begin
<tr class="notcovered"><td>759<td>    I := FBufferSize - FBufferIndex;
<tr class="notcovered"><td>760<td>    if I &gt; Size then
<tr class="notcovered"><td>761<td>      I := Size;
<tr class="notcovered"><td>762<td>    XORBuffers(Source[0], FBuffer[FBufferIndex], I, Dest[0]);
<tr class="notcovered"><td>763<td>    XORBuffers(Dest[0], FFeedback[FBufferIndex], I, FFeedback[FBufferIndex]);
<tr class="notcovered"><td>764<td>    Inc(FBufferIndex, I);
<tr class="notcovered"><td>765<td>    if FBufferIndex &lt; FBufferSize then
<tr class="nocodegen"><td>766<td>      Exit;
<tr class="notcovered"><td>767<td>    Dec(Size, I);
<tr class="notcovered"><td>768<td>    Source := @Source[I];
<tr class="notcovered"><td>769<td>    Dest := @Dest[I];
<tr class="notcovered"><td>770<td>    FBufferIndex := 0
<tr class="nocodegen"><td>771<td>  end;
<tr class="covered"><td>772<td>  Dec(Size, FBufferSize);
<tr class="covered"><td>773<td>  I := 0;
<tr class="covered"><td>774<td>  while I &lt; Size do
<tr class="nocodegen"><td>775<td>  begin
<tr class="covered"><td>776<td>    DoEncode(FFeedback, FBuffer, FBufferSize);
<tr class="covered"><td>777<td>    XORBuffers(Source[I], FBuffer[0], FBufferSize, Dest[I]);
<tr class="covered"><td>778<td>    XORBuffers(Dest[I], FFeedback[0], FBufferSize, FFeedback[0]);
<tr class="covered"><td>779<td>    Inc(I, FBufferSize);
<tr class="nocodegen"><td>780<td>  end;
<tr class="covered"><td>781<td>  Dec(Size, I - FBufferSize);
<tr class="covered"><td>782<td>  if Size &gt; 0 then
<tr class="nocodegen"><td>783<td>  begin
<tr class="covered"><td>784<td>    DoEncode(FFeedback, FBuffer, FBufferSize);
<tr class="covered"><td>785<td>    XORBuffers(Source[I], FBuffer[0], Size, Dest[I]);
<tr class="covered"><td>786<td>    XORBuffers(Dest[I], FFeedback[0], Size, FFeedback[0]);
<tr class="covered"><td>787<td>    FBufferIndex := Size;
<tr class="nocodegen"><td>788<td>  end;
<tr class="covered"><td>789<td>end;
<tr class="nocodegen"><td>790<td>
<tr class="nocodegen"><td>791<td>procedure TDECCipherModes.EncodeCBCx(Source, Dest: PByteArray; Size: Integer);
<tr class="nocodegen"><td>792<td>var
<tr class="nocodegen"><td>793<td>  F: PByteArray;
<tr class="nocodegen"><td>794<td>  I: Integer;
<tr class="covered"><td>795<td>begin
<tr class="covered"><td>796<td>  Dec(Size, FBufferSize);
<tr class="covered"><td>797<td>  F := FFeedback;
<tr class="covered"><td>798<td>  I := 0;
<tr class="covered"><td>799<td>  while I &lt;= Size do
<tr class="nocodegen"><td>800<td>  begin
<tr class="covered"><td>801<td>    XORBuffers(Source[I], F[0], FBufferSize, Dest[I]);
<tr class="covered"><td>802<td>    F := @Dest[I];
<tr class="covered"><td>803<td>    DoEncode(F, F, FBufferSize);
<tr class="covered"><td>804<td>    Inc(I, FBufferSize);
<tr class="nocodegen"><td>805<td>  end;
<tr class="covered"><td>806<td>  if F &lt;&gt; FFeedback then
<tr class="covered"><td>807<td>    Move(F[0], FFeedback[0], FBufferSize);
<tr class="covered"><td>808<td>  Dec(Size, I - FBufferSize);
<tr class="covered"><td>809<td>  if Size &gt; 0 then
<tr class="nocodegen"><td>810<td>  begin  // padding
<tr class="notcovered"><td>811<td>    EncodeCFB8(@Source[I], @Dest[I], Size);
<tr class="notcovered"><td>812<td>    FState := csPadded;
<tr class="nocodegen"><td>813<td>  end
<tr class="nocodegen"><td>814<td>  else
<tr class="covered"><td>815<td>    FState := csEncode;
<tr class="covered"><td>816<td>end;
<tr class="nocodegen"><td>817<td>
<tr class="nocodegen"><td>818<td>procedure TDECCipherModes.EncodeCTSx(Source, Dest: PByteArray; Size: Integer);
<tr class="nocodegen"><td>819<td>var
<tr class="nocodegen"><td>820<td>  I: Integer;
<tr class="covered"><td>821<td>begin
<tr class="covered"><td>822<td>  Dec(Size, FBufferSize);
<tr class="covered"><td>823<td>  I := 0;
<tr class="covered"><td>824<td>  while I &lt;= Size do
<tr class="nocodegen"><td>825<td>  begin
<tr class="covered"><td>826<td>    XORBuffers(Source[I], FFeedback[0], FBufferSize, Dest[I]);
<tr class="covered"><td>827<td>    DoEncode(@Dest[I], @Dest[I], FBufferSize);
<tr class="covered"><td>828<td>    XORBuffers(Dest[I], FFeedback[0], FBufferSize, FFeedback[0]);
<tr class="covered"><td>829<td>    Inc(I, FBufferSize);
<tr class="nocodegen"><td>830<td>  end;
<tr class="covered"><td>831<td>  Dec(Size, I - FBufferSize);
<tr class="covered"><td>832<td>  if Size &gt; 0 then
<tr class="nocodegen"><td>833<td>  begin // padding
<tr class="covered"><td>834<td>    EncodeCFS8(@Source[I], @Dest[I], Size);
<tr class="covered"><td>835<td>    FState := csPadded;
<tr class="nocodegen"><td>836<td>  end
<tr class="nocodegen"><td>837<td>  else
<tr class="covered"><td>838<td>    FState := csEncode;
<tr class="covered"><td>839<td>end;
<tr class="nocodegen"><td>840<td>
<tr class="nocodegen"><td>841<td>procedure TDECCipherModes.EncodeGCM(Source, Dest: PByteArray; Size: Integer);
<tr class="nocodegen"><td>842<td>var
<tr class="nocodegen"><td>843<td>  PlainText,
<tr class="nocodegen"><td>844<td>  CipherText : TBytes;
<tr class="covered"><td>845<td>begin
<tr class="covered"><td>846<td>  if (Size &gt; 0) then
<tr class="nocodegen"><td>847<td>  begin
<tr class="covered"><td>848<td>    PlainText  := TBytes(@Source^);
<tr class="covered"><td>849<td>    CipherText := TBytes(@Dest^);
<tr class="nocodegen"><td>850<td>  end
<tr class="nocodegen"><td>851<td>  else
<tr class="nocodegen"><td>852<td>  begin
<tr class="covered"><td>853<td>    SetLength(PlainText, 0);
<tr class="covered"><td>854<td>    SetLength(CipherText, 0);
<tr class="nocodegen"><td>855<td>  end;
<tr class="nocodegen"><td>856<td>
<tr class="covered"><td>857<td>  FGCM.EncodeGCM(PlainText, CipherText, Size);
<tr class="covered"><td>858<td>end;
<tr class="nocodegen"><td>859<td>
<tr class="nocodegen"><td>860<td>{$IFDEF DEC3_CMCTS}
<tr class="nocodegen"><td>861<td>procedure TDECCipherModes.EncodeCTS3(Source, Dest: PByteArray; Size: Integer);
<tr class="nocodegen"><td>862<td>var
<tr class="nocodegen"><td>863<td>  I: Integer;
<tr class="nocodegen"><td>864<td>begin
<tr class="nocodegen"><td>865<td>  Dec(Size, FBufferSize);
<tr class="nocodegen"><td>866<td>  I := 0;
<tr class="nocodegen"><td>867<td>  while I &lt;= Size do
<tr class="nocodegen"><td>868<td>  begin
<tr class="nocodegen"><td>869<td>    XORBuffers(Source[I], FFeedback[0], FBufferSize, Dest[I]);
<tr class="nocodegen"><td>870<td>    DoEncode(@Dest[I], @Dest[I], FBufferSize);
<tr class="nocodegen"><td>871<td>    XORBuffers(Dest[I], FFeedback[0], FBufferSize, FFeedback[0]);
<tr class="nocodegen"><td>872<td>    Inc(I, FBufferSize);
<tr class="nocodegen"><td>873<td>  end;
<tr class="nocodegen"><td>874<td>  Dec(Size, I - FBufferSize);
<tr class="nocodegen"><td>875<td>  if Size &gt; 0 then
<tr class="nocodegen"><td>876<td>  begin // padding
<tr class="nocodegen"><td>877<td>    EncodeCFSx(@Source[I], @Dest[I], Size); // use the padding implemented in CFSx
<tr class="nocodegen"><td>878<td>    FState := csPadded;
<tr class="nocodegen"><td>879<td>  end
<tr class="nocodegen"><td>880<td>  else
<tr class="nocodegen"><td>881<td>    FState := csEncode;
<tr class="nocodegen"><td>882<td>end;
<tr class="nocodegen"><td>883<td>{$ENDIF DEC3_CMCTS}
<tr class="nocodegen"><td>884<td>
<tr class="nocodegen"><td>885<td>procedure TDECCipherModes.Decode(const Source; var Dest; DataSize: Integer);
<tr class="covered"><td>886<td>begin
<tr class="covered"><td>887<td>  CheckState([csInitialized, csDecode, csDone]);
<tr class="nocodegen"><td>888<td>
<tr class="covered"><td>889<td>  case FMode of
<tr class="covered"><td>890<td>    cmECBx:   DecodeECBx(@Source, @Dest, DataSize);
<tr class="covered"><td>891<td>    cmCBCx:   DecodeCBCx(@Source, @Dest, DataSize);
<tr class="covered"><td>892<td>    cmCTSx:   DecodeCTSx(@Source, @Dest, DataSize);
<tr class="nocodegen"><td>893<td>    {$IFDEF DEC3_CMCTS}
<tr class="nocodegen"><td>894<td>    cmCTS3:   DecodeCTS3(@Source, @Dest, DataSize);
<tr class="nocodegen"><td>895<td>    {$ENDIF DEC3_CMCTS}
<tr class="covered"><td>896<td>    cmCFB8:   DecodeCFB8(@Source, @Dest, DataSize);
<tr class="covered"><td>897<td>    cmCFBx:   DecodeCFBx(@Source, @Dest, DataSize);
<tr class="covered"><td>898<td>    cmOFB8:   DecodeOFB8(@Source, @Dest, DataSize);
<tr class="covered"><td>899<td>    cmOFBx:   DecodeOFBx(@Source, @Dest, DataSize);
<tr class="covered"><td>900<td>    cmCFS8:   DecodeCFS8(@Source, @Dest, DataSize);
<tr class="covered"><td>901<td>    cmCFSx:   DecodeCFSx(@Source, @Dest, DataSize);
<tr class="covered"><td>902<td>    cmGCM :   DecodeGCM(@Source, @Dest, DataSize);
<tr class="nocodegen"><td>903<td>  end;
<tr class="covered"><td>904<td>end;
<tr class="nocodegen"><td>905<td>
<tr class="nocodegen"><td>906<td>procedure TDECCipherModes.DecodeECBx(Source, Dest: PByteArray; Size: Integer);
<tr class="nocodegen"><td>907<td>var
<tr class="nocodegen"><td>908<td>  I: Integer;
<tr class="covered"><td>909<td>begin
<tr class="covered"><td>910<td>  if Context.BlockSize = 1 then
<tr class="nocodegen"><td>911<td>  begin
<tr class="covered"><td>912<td>    DoDecode(Source, Dest, Size);
<tr class="covered"><td>913<td>    FState := csDecode;
<tr class="nocodegen"><td>914<td>  end
<tr class="nocodegen"><td>915<td>  else
<tr class="nocodegen"><td>916<td>  begin
<tr class="covered"><td>917<td>    Dec(Size, FBufferSize);
<tr class="covered"><td>918<td>    I := 0;
<tr class="covered"><td>919<td>    while I &lt;= Size do
<tr class="nocodegen"><td>920<td>    begin
<tr class="covered"><td>921<td>      DoDecode(@Source[I], @Dest[I], FBufferSize);
<tr class="covered"><td>922<td>      Inc(I, FBufferSize);
<tr class="nocodegen"><td>923<td>    end;
<tr class="covered"><td>924<td>    Dec(Size, I - FBufferSize);
<tr class="covered"><td>925<td>    if Size &gt; 0 then
<tr class="nocodegen"><td>926<td>    begin
<tr class="covered"><td>927<td>      if Size mod Context.BlockSize = 0 then
<tr class="nocodegen"><td>928<td>      begin
<tr class="covered"><td>929<td>        DoDecode(@Source[I], @Dest[I], Size);
<tr class="covered"><td>930<td>        FState := csDecode;
<tr class="nocodegen"><td>931<td>      end
<tr class="nocodegen"><td>932<td>      else
<tr class="nocodegen"><td>933<td>      begin
<tr class="covered"><td>934<td>        FState := csPadded;
<tr class="covered"><td>935<td>        ReportInvalidMessageLength(Self);
<tr class="nocodegen"><td>936<td>      end;
<tr class="nocodegen"><td>937<td>    end;
<tr class="nocodegen"><td>938<td>  end;
<tr class="covered"><td>939<td>end;
<tr class="nocodegen"><td>940<td>
<tr class="nocodegen"><td>941<td>procedure TDECCipherModes.DecodeGCM(Source, Dest: PByteArray; Size: Integer);
<tr class="nocodegen"><td>942<td>var
<tr class="nocodegen"><td>943<td>  PlainText,
<tr class="nocodegen"><td>944<td>  CipherText : TBytes;
<tr class="covered"><td>945<td>begin
<tr class="covered"><td>946<td>  if (Size &gt; 0) then
<tr class="nocodegen"><td>947<td>  begin
<tr class="covered"><td>948<td>    PlainText  := TBytes(@Source^);
<tr class="covered"><td>949<td>    CipherText := TBytes(@Dest^);
<tr class="nocodegen"><td>950<td>  end
<tr class="nocodegen"><td>951<td>  else
<tr class="nocodegen"><td>952<td>  begin
<tr class="covered"><td>953<td>    SetLength(PlainText, 0);
<tr class="covered"><td>954<td>    SetLength(CipherText, 0);
<tr class="nocodegen"><td>955<td>  end;
<tr class="nocodegen"><td>956<td>
<tr class="covered"><td>957<td>  FGCM.DecodeGCM(PlainText, CipherText, Size);
<tr class="covered"><td>958<td>end;
<tr class="nocodegen"><td>959<td>
<tr class="nocodegen"><td>960<td>procedure TDECCipherModes.DecodeCFB8(Source, Dest: PByteArray; Size: Integer);
<tr class="nocodegen"><td>961<td>// CFB-8
<tr class="nocodegen"><td>962<td>var
<tr class="nocodegen"><td>963<td>  I: Integer;
<tr class="covered"><td>964<td>begin
<tr class="covered"><td>965<td>  I := 0;
<tr class="covered"><td>966<td>  while I &lt; Size do
<tr class="nocodegen"><td>967<td>  begin
<tr class="covered"><td>968<td>    DoEncode(FFeedback, FBuffer, FBufferSize);
<tr class="covered"><td>969<td>    Move(FFeedback[1], FFeedback[0], FBufferSize - 1);
<tr class="covered"><td>970<td>    FFeedback[FBufferSize - 1] := Source[I];
<tr class="covered"><td>971<td>    Dest[I] := Source[I] xor FBuffer[0];
<tr class="covered"><td>972<td>    Inc(I);
<tr class="nocodegen"><td>973<td>  end;
<tr class="covered"><td>974<td>  FState := csDecode;
<tr class="covered"><td>975<td>end;
<tr class="nocodegen"><td>976<td>
<tr class="nocodegen"><td>977<td>procedure TDECCipherModes.DecodeOFB8(Source, Dest: PByteArray; Size: Integer);
<tr class="nocodegen"><td>978<td>// same as EncodeOFB
<tr class="nocodegen"><td>979<td>var
<tr class="nocodegen"><td>980<td>  I: Integer;
<tr class="covered"><td>981<td>begin
<tr class="covered"><td>982<td>  I := 0;
<tr class="covered"><td>983<td>  while I &lt; Size do
<tr class="nocodegen"><td>984<td>  begin
<tr class="covered"><td>985<td>    DoEncode(FFeedback, FBuffer, FBufferSize);
<tr class="covered"><td>986<td>    Move(FFeedback[1], FFeedback[0], FBufferSize - 1);
<tr class="covered"><td>987<td>    FFeedback[FBufferSize - 1] := FBuffer[0];
<tr class="covered"><td>988<td>    Dest[I] := Source[I] xor FBuffer[0];
<tr class="covered"><td>989<td>    Inc(I);
<tr class="nocodegen"><td>990<td>  end;
<tr class="covered"><td>991<td>  FState := csDecode;
<tr class="covered"><td>992<td>end;
<tr class="nocodegen"><td>993<td>
<tr class="nocodegen"><td>994<td>procedure TDECCipherModes.DecodeCFS8(Source, Dest: PByteArray; Size: Integer);
<tr class="nocodegen"><td>995<td>var
<tr class="nocodegen"><td>996<td>  I: Integer;
<tr class="covered"><td>997<td>begin
<tr class="covered"><td>998<td>  I := 0;
<tr class="covered"><td>999<td>  while I &lt; Size do
<tr class="nocodegen"><td>1000<td>  begin
<tr class="covered"><td>1001<td>    DoEncode(FFeedback, FBuffer, FBufferSize);
<tr class="covered"><td>1002<td>    Move(FFeedback[1], FFeedback[0], FBufferSize - 1);
<tr class="covered"><td>1003<td>    FFeedback[FBufferSize - 1] := FFeedback[FBufferSize - 1] xor Source[I];
<tr class="covered"><td>1004<td>    Dest[I] := Source[I] xor FBuffer[0];
<tr class="covered"><td>1005<td>    Inc(I);
<tr class="nocodegen"><td>1006<td>  end;
<tr class="covered"><td>1007<td>  FState := csDecode;
<tr class="covered"><td>1008<td>end;
<tr class="nocodegen"><td>1009<td>
<tr class="nocodegen"><td>1010<td>procedure TDECCipherModes.DecodeCFBx(Source, Dest: PByteArray; Size: Integer);
<tr class="nocodegen"><td>1011<td>// CFB-BlockSize
<tr class="nocodegen"><td>1012<td>var
<tr class="nocodegen"><td>1013<td>  I: Integer;
<tr class="nocodegen"><td>1014<td>  F: PByteArray;
<tr class="covered"><td>1015<td>begin
<tr class="covered"><td>1016<td>  FState := csDecode;
<tr class="covered"><td>1017<td>  if FBufferIndex &gt; 0 then
<tr class="nocodegen"><td>1018<td>  begin // remaining bytes of last decode
<tr class="notcovered"><td>1019<td>    I := FBufferSize - FBufferIndex;
<tr class="notcovered"><td>1020<td>    if I &gt; Size then
<tr class="notcovered"><td>1021<td>      I := Size;
<tr class="notcovered"><td>1022<td>    Move(Source[0], FFeedback[FBufferIndex], I);
<tr class="notcovered"><td>1023<td>    XORBuffers(Source[0], FBuffer[FBufferIndex], I, Dest[0]);
<tr class="notcovered"><td>1024<td>    Inc(FBufferIndex, I);
<tr class="notcovered"><td>1025<td>    if FBufferIndex &lt; FBufferSize then
<tr class="nocodegen"><td>1026<td>      Exit;
<tr class="notcovered"><td>1027<td>    Dec(Size, I);
<tr class="notcovered"><td>1028<td>    Source := @Source[I];
<tr class="notcovered"><td>1029<td>    Dest := @Dest[I];
<tr class="notcovered"><td>1030<td>    FBufferIndex := 0
<tr class="nocodegen"><td>1031<td>  end;
<tr class="nocodegen"><td>1032<td>  // process chunks of FBufferSize bytes
<tr class="covered"><td>1033<td>  Dec(Size, FBufferSize);
<tr class="covered"><td>1034<td>  I := 0;
<tr class="covered"><td>1035<td>  if Source &lt;&gt; Dest then
<tr class="nocodegen"><td>1036<td>  begin
<tr class="covered"><td>1037<td>    F := FFeedback;
<tr class="covered"><td>1038<td>    while I &lt; Size do
<tr class="nocodegen"><td>1039<td>    begin
<tr class="covered"><td>1040<td>      DoEncode(F, FBuffer, FBufferSize);
<tr class="covered"><td>1041<td>      XORBuffers(Source[I], FBuffer[0], FBufferSize, Dest[I]);
<tr class="covered"><td>1042<td>      F := @Source[I];
<tr class="covered"><td>1043<td>      Inc(I, FBufferSize);
<tr class="nocodegen"><td>1044<td>    end;
<tr class="covered"><td>1045<td>    if F &lt;&gt; FFeedback then
<tr class="covered"><td>1046<td>      Move(F^, FFeedback^, FBufferSize);
<tr class="nocodegen"><td>1047<td>  end
<tr class="nocodegen"><td>1048<td>  else
<tr class="notcovered"><td>1049<td>    while I &lt; Size do
<tr class="nocodegen"><td>1050<td>    begin
<tr class="notcovered"><td>1051<td>      DoEncode(FFeedback, FBuffer, FBufferSize);
<tr class="notcovered"><td>1052<td>      Move(Source[I], FFeedback[0], FBufferSize);
<tr class="notcovered"><td>1053<td>      XORBuffers(Source[I], FBuffer[0], FBufferSize, Dest[I]);
<tr class="notcovered"><td>1054<td>      Inc(I, FBufferSize);
<tr class="nocodegen"><td>1055<td>    end;
<tr class="covered"><td>1056<td>  Dec(Size, I - FBufferSize);
<tr class="covered"><td>1057<td>  if Size &gt; 0 then
<tr class="nocodegen"><td>1058<td>  begin // remaining bytes
<tr class="covered"><td>1059<td>    DoEncode(FFeedback, FBuffer, FBufferSize);
<tr class="covered"><td>1060<td>    Move(Source[I], FFeedback[0], Size);
<tr class="covered"><td>1061<td>    XORBuffers(Source[I], FBuffer[0], Size, Dest[I]);
<tr class="covered"><td>1062<td>    FBufferIndex := Size;
<tr class="nocodegen"><td>1063<td>  end;
<tr class="covered"><td>1064<td>end;
<tr class="nocodegen"><td>1065<td>
<tr class="nocodegen"><td>1066<td>procedure TDECCipherModes.DecodeOFBx(Source, Dest: PByteArray; Size: Integer);
<tr class="nocodegen"><td>1067<td>// OFB-BlockSize, same as EncodeOFBx
<tr class="nocodegen"><td>1068<td>var
<tr class="nocodegen"><td>1069<td>  I: Integer;
<tr class="covered"><td>1070<td>begin
<tr class="covered"><td>1071<td>  FState := csDecode;
<tr class="covered"><td>1072<td>  if FBufferIndex &gt; 0 then
<tr class="nocodegen"><td>1073<td>  begin
<tr class="notcovered"><td>1074<td>    I := FBufferSize - FBufferIndex;
<tr class="notcovered"><td>1075<td>    if I &gt; Size then
<tr class="notcovered"><td>1076<td>      I := Size;
<tr class="notcovered"><td>1077<td>    XORBuffers(Source[0], FFeedback[FBufferIndex], I, Dest[0]);
<tr class="notcovered"><td>1078<td>    Inc(FBufferIndex, I);
<tr class="notcovered"><td>1079<td>    if FBufferIndex &lt; FBufferSize then
<tr class="nocodegen"><td>1080<td>      Exit;
<tr class="notcovered"><td>1081<td>    Dec(Size, I);
<tr class="notcovered"><td>1082<td>    Source := @Source[I];
<tr class="notcovered"><td>1083<td>    Dest := @Dest[I];
<tr class="notcovered"><td>1084<td>    FBufferIndex := 0
<tr class="nocodegen"><td>1085<td>  end;
<tr class="covered"><td>1086<td>  Dec(Size, FBufferSize);
<tr class="covered"><td>1087<td>  I := 0;
<tr class="covered"><td>1088<td>  while I &lt; Size do
<tr class="nocodegen"><td>1089<td>  begin
<tr class="covered"><td>1090<td>    DoEncode(FFeedback, FFeedback, FBufferSize);
<tr class="covered"><td>1091<td>    XORBuffers(Source[I], FFeedback[0], FBufferSize, Dest[I]);
<tr class="covered"><td>1092<td>    Inc(I, FBufferSize);
<tr class="nocodegen"><td>1093<td>  end;
<tr class="covered"><td>1094<td>  Dec(Size, I - FBufferSize);
<tr class="covered"><td>1095<td>  if Size &gt; 0 then
<tr class="nocodegen"><td>1096<td>  begin
<tr class="covered"><td>1097<td>    DoEncode(FFeedback, FFeedback, FBufferSize);
<tr class="covered"><td>1098<td>    XORBuffers(Source[I], FFeedback[0], Size, Dest[I]);
<tr class="covered"><td>1099<td>    FBufferIndex := Size;
<tr class="nocodegen"><td>1100<td>  end;
<tr class="covered"><td>1101<td>end;
<tr class="nocodegen"><td>1102<td>
<tr class="nocodegen"><td>1103<td>destructor TDECCipherModes.Destroy;
<tr class="covered"><td>1104<td>begin
<tr class="covered"><td>1105<td>  FGCM.Free;
<tr class="nocodegen"><td>1106<td>
<tr class="covered"><td>1107<td>  inherited;
<tr class="covered"><td>1108<td>end;
<tr class="nocodegen"><td>1109<td>
<tr class="nocodegen"><td>1110<td>procedure TDECCipherModes.Done;
<tr class="covered"><td>1111<td>begin
<tr class="covered"><td>1112<td>  inherited;
<tr class="nocodegen"><td>1113<td>
<tr class="covered"><td>1114<td>  if (FMode = cmGCM) then
<tr class="nocodegen"><td>1115<td>  begin
<tr class="covered"><td>1116<td>    if (length(FGCM.ExpectedAuthenticationTag) &gt; 0) and
<tr class="nocodegen"><td>1117<td>       (not IsEqual(FGCM.ExpectedAuthenticationTag, FGCM.CalculatedAuthenticationTag)) then
<tr class="covered"><td>1118<td>      raise EDECCipherAuthenticationException.Create(sInvalidAuthenticationValue);
<tr class="nocodegen"><td>1119<td>  end;
<tr class="covered"><td>1120<td>end;
<tr class="nocodegen"><td>1121<td>
<tr class="nocodegen"><td>1122<td>procedure TDECCipherModes.OnAfterInitVectorInitialization(const OriginalInitVector: TBytes);
<tr class="covered"><td>1123<td>begin
<tr class="nocodegen"><td>1124<td>  inherited;
<tr class="nocodegen"><td>1125<td>
<tr class="covered"><td>1126<td>  if (FMode = cmGCM) then
<tr class="covered"><td>1127<td>    FGCM.Init(self.DoEncode, OriginalInitVector);
<tr class="covered"><td>1128<td>end;
<tr class="nocodegen"><td>1129<td>
<tr class="nocodegen"><td>1130<td>procedure TDECCipherModes.DecodeCFSx(Source, Dest: PByteArray; Size: Integer);
<tr class="nocodegen"><td>1131<td>// CFS-BlockSize
<tr class="nocodegen"><td>1132<td>var
<tr class="nocodegen"><td>1133<td>  I: Integer;
<tr class="covered"><td>1134<td>begin
<tr class="covered"><td>1135<td>  FState := csDecode;
<tr class="covered"><td>1136<td>  if FBufferIndex &gt; 0 then
<tr class="nocodegen"><td>1137<td>  begin // remaining bytes of last decode
<tr class="notcovered"><td>1138<td>    I := FBufferSize - FBufferIndex;
<tr class="notcovered"><td>1139<td>    if I &gt; Size then
<tr class="notcovered"><td>1140<td>      I := Size;
<tr class="notcovered"><td>1141<td>    XORBuffers(Source[0], FFeedback[FBufferIndex], I, FFeedback[FBufferIndex]);
<tr class="notcovered"><td>1142<td>    XORBuffers(Source[0], FBuffer[FBufferIndex], I, Dest[0]);
<tr class="notcovered"><td>1143<td>    Inc(FBufferIndex, I);
<tr class="notcovered"><td>1144<td>    if FBufferIndex &lt; FBufferSize then
<tr class="nocodegen"><td>1145<td>      Exit;
<tr class="notcovered"><td>1146<td>    Dec(Size, I);
<tr class="notcovered"><td>1147<td>    Source := @Source[I];
<tr class="notcovered"><td>1148<td>    Dest := @Dest[I];
<tr class="notcovered"><td>1149<td>    FBufferIndex := 0
<tr class="nocodegen"><td>1150<td>  end;
<tr class="nocodegen"><td>1151<td>  // process chunks of FBufferSize bytes
<tr class="covered"><td>1152<td>  Dec(Size, FBufferSize);
<tr class="covered"><td>1153<td>  I := 0;
<tr class="covered"><td>1154<td>  while I &lt; Size do
<tr class="nocodegen"><td>1155<td>  begin
<tr class="covered"><td>1156<td>    DoEncode(FFeedback, FBuffer, FBufferSize);
<tr class="covered"><td>1157<td>    XORBuffers(Source[I], FFeedback[0], FBufferSize, FFeedback[0]);
<tr class="covered"><td>1158<td>    XORBuffers(Source[I], FBuffer[0], FBufferSize, Dest[I]);
<tr class="covered"><td>1159<td>    Inc(I, FBufferSize);
<tr class="nocodegen"><td>1160<td>  end;
<tr class="covered"><td>1161<td>  Dec(Size, I - FBufferSize);
<tr class="covered"><td>1162<td>  if Size &gt; 0 then
<tr class="nocodegen"><td>1163<td>  begin // remaining bytes
<tr class="covered"><td>1164<td>    DoEncode(FFeedback, FBuffer, FBufferSize);
<tr class="covered"><td>1165<td>    XORBuffers(Source[I], FFeedback[0], Size, FFeedback[0]);
<tr class="covered"><td>1166<td>    XORBuffers(Source[I], FBuffer[0], Size, Dest[I]);
<tr class="covered"><td>1167<td>    FBufferIndex := Size;
<tr class="nocodegen"><td>1168<td>  end;
<tr class="covered"><td>1169<td>end;
<tr class="nocodegen"><td>1170<td>
<tr class="nocodegen"><td>1171<td>procedure TDECCipherModes.DecodeCBCx(Source, Dest: PByteArray; Size: Integer);
<tr class="nocodegen"><td>1172<td>var
<tr class="nocodegen"><td>1173<td>  I: Integer;
<tr class="nocodegen"><td>1174<td>  F, B, T: PByteArray;
<tr class="covered"><td>1175<td>begin
<tr class="covered"><td>1176<td>  Dec(Size, FBufferSize);
<tr class="covered"><td>1177<td>  F := FFeedback;
<tr class="covered"><td>1178<td>  I := 0;
<tr class="covered"><td>1179<td>  if Source = Dest then
<tr class="nocodegen"><td>1180<td>  begin
<tr class="covered"><td>1181<td>    B := FBuffer;
<tr class="covered"><td>1182<td>    while I &lt;= Size do
<tr class="nocodegen"><td>1183<td>    begin
<tr class="covered"><td>1184<td>      Move(Source[I], B[0], FBufferSize);
<tr class="covered"><td>1185<td>      DoDecode(@Source[I], @Source[I], FBufferSize);
<tr class="covered"><td>1186<td>      XORBuffers(Source[I], F[0], FBufferSize, Source[I]);
<tr class="covered"><td>1187<td>      T := F;
<tr class="covered"><td>1188<td>      F := B;
<tr class="covered"><td>1189<td>      B := T;
<tr class="covered"><td>1190<td>      Inc(I, FBufferSize);
<tr class="nocodegen"><td>1191<td>    end;
<tr class="nocodegen"><td>1192<td>  end
<tr class="nocodegen"><td>1193<td>  else
<tr class="nocodegen"><td>1194<td>  begin
<tr class="covered"><td>1195<td>    while I &lt;= Size do
<tr class="nocodegen"><td>1196<td>    begin
<tr class="covered"><td>1197<td>      DoDecode(@Source[I], @Dest[I], FBufferSize);
<tr class="covered"><td>1198<td>      XORBuffers(F[0], Dest[I], FBufferSize, Dest[I]);
<tr class="covered"><td>1199<td>      F := @Source[I];
<tr class="covered"><td>1200<td>      Inc(I, FBufferSize);
<tr class="nocodegen"><td>1201<td>    end;
<tr class="nocodegen"><td>1202<td>  end;
<tr class="covered"><td>1203<td>  if F &lt;&gt; FFeedback then
<tr class="covered"><td>1204<td>    Move(F[0], FFeedback[0], FBufferSize);
<tr class="covered"><td>1205<td>  Dec(Size, I - FBufferSize);
<tr class="covered"><td>1206<td>  if Size &gt; 0 then
<tr class="nocodegen"><td>1207<td>  begin
<tr class="notcovered"><td>1208<td>    DecodeCFB8(@Source[I], @Dest[I], Size);
<tr class="notcovered"><td>1209<td>    FState := csPadded;
<tr class="nocodegen"><td>1210<td>  end
<tr class="nocodegen"><td>1211<td>  else
<tr class="covered"><td>1212<td>    FState := csDecode;
<tr class="covered"><td>1213<td>end;
<tr class="nocodegen"><td>1214<td>
<tr class="nocodegen"><td>1215<td>procedure TDECCipherModes.DecodeCTSx(Source, Dest: PByteArray; Size: Integer);
<tr class="nocodegen"><td>1216<td>var
<tr class="nocodegen"><td>1217<td>  I: Integer;
<tr class="nocodegen"><td>1218<td>  F, B, T: PByteArray;
<tr class="covered"><td>1219<td>begin
<tr class="covered"><td>1220<td>  Dec(Size, FBufferSize);
<tr class="covered"><td>1221<td>  F := FFeedback;
<tr class="covered"><td>1222<td>  B := FBuffer;
<tr class="covered"><td>1223<td>  I := 0;
<tr class="covered"><td>1224<td>  while I &lt;= Size do
<tr class="nocodegen"><td>1225<td>  begin
<tr class="covered"><td>1226<td>    XORBuffers(Source[I], F[0], FBufferSize, B[0]);
<tr class="covered"><td>1227<td>    DoDecode(@Source[I], @Dest[I], FBufferSize);
<tr class="covered"><td>1228<td>    XORBuffers(Dest[I], F[0], FBufferSize, Dest[I]);
<tr class="covered"><td>1229<td>    T := B;
<tr class="covered"><td>1230<td>    B := F;
<tr class="covered"><td>1231<td>    F := T;
<tr class="covered"><td>1232<td>    Inc(I, FBufferSize);
<tr class="nocodegen"><td>1233<td>  end;
<tr class="covered"><td>1234<td>  if F &lt;&gt; FFeedback then
<tr class="covered"><td>1235<td>    Move(F[0], FFeedback[0], FBufferSize);
<tr class="covered"><td>1236<td>  Dec(Size, I - FBufferSize);
<tr class="covered"><td>1237<td>  if Size &gt; 0 then
<tr class="nocodegen"><td>1238<td>  begin
<tr class="covered"><td>1239<td>    DecodeCFS8(@Source[I], @Dest[I], Size);
<tr class="covered"><td>1240<td>    FState := csPadded;
<tr class="nocodegen"><td>1241<td>  end
<tr class="nocodegen"><td>1242<td>  else
<tr class="covered"><td>1243<td>    FState := csDecode;
<tr class="covered"><td>1244<td>end;
<tr class="nocodegen"><td>1245<td>
<tr class="nocodegen"><td>1246<td>{$IFDEF DEC3_CMCTS}
<tr class="nocodegen"><td>1247<td>procedure DecodeCTS3(Source, Dest: PByteArray; Size: Integer);
<tr class="nocodegen"><td>1248<td>var
<tr class="nocodegen"><td>1249<td>  I: Integer;
<tr class="nocodegen"><td>1250<td>  F, B, T: PByteArray;
<tr class="nocodegen"><td>1251<td>begin
<tr class="nocodegen"><td>1252<td>  Dec(Size, FBufferSize);
<tr class="nocodegen"><td>1253<td>  F := FFeedback;
<tr class="nocodegen"><td>1254<td>  B := FBuffer;
<tr class="nocodegen"><td>1255<td>  I := 0;
<tr class="nocodegen"><td>1256<td>  while I &lt;= Size do
<tr class="nocodegen"><td>1257<td>  begin
<tr class="nocodegen"><td>1258<td>    XORBuffers(Source[I], F[0], FBufferSize, B[0]);
<tr class="nocodegen"><td>1259<td>    DoDecode(@Source[I], @Dest[I], FBufferSize);
<tr class="nocodegen"><td>1260<td>    XORBuffers(Dest[I], F[0], FBufferSize, Dest[I]);
<tr class="nocodegen"><td>1261<td>    T := B;
<tr class="nocodegen"><td>1262<td>    B := F;
<tr class="nocodegen"><td>1263<td>    F := T;
<tr class="nocodegen"><td>1264<td>    Inc(I, FBufferSize);
<tr class="nocodegen"><td>1265<td>  end;
<tr class="nocodegen"><td>1266<td>  if F &lt;&gt; FFeedback then
<tr class="nocodegen"><td>1267<td>    Move(F[0], FFeedback[0], FBufferSize);
<tr class="nocodegen"><td>1268<td>  Dec(Size, I - FBufferSize);
<tr class="nocodegen"><td>1269<td>  if Size &gt; 0 then
<tr class="nocodegen"><td>1270<td>  begin
<tr class="nocodegen"><td>1271<td>    DecodeCFSx(@Source[I], @Dest[I], Size); // use the padding implemented in CFSx
<tr class="nocodegen"><td>1272<td>    FState := csPadded;
<tr class="nocodegen"><td>1273<td>  end
<tr class="nocodegen"><td>1274<td>  else
<tr class="nocodegen"><td>1275<td>    FState := csDecode;
<tr class="nocodegen"><td>1276<td>end;
<tr class="nocodegen"><td>1277<td>{$ENDIF DEC3_CMCTS}
<tr class="nocodegen"><td>1278<td>
<tr class="nocodegen"><td>1279<td>end.
</table>
<script>(function () {
var starts = [],prev = document.getElementById("nav-prev"),next = document.getElementById("nav-next");
(function () {
var p;
document.querySelectorAll("table.s tr").forEach(r => {
if (r.classList.contains("notcovered")) {
if (!p) starts.push(r);
p = r;
} else { p = null }
})
})();
function findPrev() {
var y = prev.getBoundingClientRect().top - 4;
for (var i=starts.length-1; i>=0; i--) {
if (starts[i].getBoundingClientRect().top < y) return starts[i]
}
}
function findNext() {
var y = next.getBoundingClientRect().top + 4;
for (var i=0; i<starts.length; i++) {
if (starts[i].getBoundingClientRect().top > y) return starts[i];
}
}
function onScroll() {
prev.setAttribute("class", findPrev() ? "active" : "");
next.setAttribute("class", findNext() ? "active" : "");
onScroll.pending = 0;
}
document.addEventListener("scroll", function() {
if (!onScroll.pending) { onScroll.pending = requestAnimationFrame(onScroll) }
});
onScroll();
function scrollTo(row) {
if (row) window.scrollTo({ behavior: "smooth", top: window.scrollY+row.getBoundingClientRect().top-prev.getBoundingClientRect().top });
}
next.addEventListener("click", () => scrollTo(findNext()) );
prev.addEventListener("click", () => scrollTo(findPrev()) );
})();</script>
<script>
const getCellValue = (tr, idx) => tr.children[idx].innerText || tr.children[idx].textContent;
const comparer = (idx, asc) => (a, b) => ((v1, v2) =>!isNaN(parseFloat(v1 || "-")) && !isNaN(parseFloat(v2 || "-")) ? parseFloat(v1)-parseFloat(v2) : v1.toString().localeCompare(v2))(getCellValue(asc ? a : b, idx), getCellValue(asc ? b : a, idx));
document.querySelectorAll("thead th[idx]").forEach(th => th.addEventListener("click", (() => {
	const table = th.closest("table").querySelector("tbody");
	Array.from(table.querySelectorAll("tr"))
		.sort(comparer(+th.getAttribute("idx"), this.asc = !this.asc))
		.forEach(tr => table.appendChild(tr) );
	})));
</script>
</body>
</html>
